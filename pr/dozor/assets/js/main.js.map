{"version":3,"sources":["main.js","modal/modal.js","nav/nav-list/nav-list.js","main_end.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtrFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxCA","file":"main.js","sourcesContent":["//= ../../../bower_components/jquery/dist/jquery.min.js\n//= ../../../bower_components/fancybox/source/jquery.fancybox.pack.js\n$(function(){","\r\n// modal\r\n$('.header__btn').fancybox();\r\n\r\n/*!\r\n* jquery.inputmask.bundle.js\r\n* https://github.com/RobinHerbots/jquery.inputmask\r\n* Copyright (c) 2010 - 2016 Robin Herbots\r\n* Licensed under the MIT license (http://www.opensource.org/licenses/mit-license.php)\r\n* Version: 3.3.4-92\r\n*/\r\n!function($) {\r\n    function Inputmask(alias, options) {\r\n        return this instanceof Inputmask ? ($.isPlainObject(alias) ? options = alias : (options = options || {}, \r\n        options.alias = alias), this.el = void 0, this.opts = $.extend(!0, {}, this.defaults, options), \r\n        this.noMasksCache = options && void 0 !== options.definitions, this.userOptions = options || {}, \r\n        this.events = {}, this.dataAttribute = \"data-inputmask\", void resolveAlias(this.opts.alias, options, this.opts)) : new Inputmask(alias, options);\r\n    }\r\n    function isInputEventSupported(eventName) {\r\n        var el = document.createElement(\"input\"), evName = \"on\" + eventName, isSupported = evName in el;\r\n        return isSupported || (el.setAttribute(evName, \"return;\"), isSupported = \"function\" == typeof el[evName]), \r\n        el = null, isSupported;\r\n    }\r\n    function isElementTypeSupported(input, opts) {\r\n        var elementType = input.getAttribute(\"type\"), isSupported = \"INPUT\" === input.tagName && $.inArray(elementType, opts.supportsInputType) !== -1 || input.isContentEditable || \"TEXTAREA\" === input.tagName;\r\n        if (!isSupported && \"INPUT\" === input.tagName) {\r\n            var el = document.createElement(\"input\");\r\n            el.setAttribute(\"type\", elementType), isSupported = \"text\" === el.type, el = null;\r\n        }\r\n        return isSupported;\r\n    }\r\n    function resolveAlias(aliasStr, options, opts) {\r\n        var aliasDefinition = opts.aliases[aliasStr];\r\n        return aliasDefinition ? (aliasDefinition.alias && resolveAlias(aliasDefinition.alias, void 0, opts), \r\n        $.extend(!0, opts, aliasDefinition), $.extend(!0, opts, options), !0) : (null === opts.mask && (opts.mask = aliasStr), \r\n        !1);\r\n    }\r\n    function importAttributeOptions(npt, opts, userOptions, dataAttribute) {\r\n        function importOption(option, optionData) {\r\n            optionData = void 0 !== optionData ? optionData : npt.getAttribute(dataAttribute + \"-\" + option), \r\n            null !== optionData && (\"string\" == typeof optionData && (0 === option.indexOf(\"on\") ? optionData = window[optionData] : \"false\" === optionData ? optionData = !1 : \"true\" === optionData && (optionData = !0)), \r\n            userOptions[option] = optionData);\r\n        }\r\n        var option, dataoptions, optionData, p, attrOptions = npt.getAttribute(dataAttribute);\r\n        if (attrOptions && \"\" !== attrOptions && (attrOptions = attrOptions.replace(new RegExp(\"'\", \"g\"), '\"'), \r\n        dataoptions = JSON.parse(\"{\" + attrOptions + \"}\")), dataoptions) {\r\n            optionData = void 0;\r\n            for (p in dataoptions) if (\"alias\" === p.toLowerCase()) {\r\n                optionData = dataoptions[p];\r\n                break;\r\n            }\r\n        }\r\n        importOption(\"alias\", optionData), userOptions.alias && resolveAlias(userOptions.alias, userOptions, opts);\r\n        for (option in opts) {\r\n            if (dataoptions) {\r\n                optionData = void 0;\r\n                for (p in dataoptions) if (p.toLowerCase() === option.toLowerCase()) {\r\n                    optionData = dataoptions[p];\r\n                    break;\r\n                }\r\n            }\r\n            importOption(option, optionData);\r\n        }\r\n        return $.extend(!0, opts, userOptions), opts;\r\n    }\r\n    function generateMaskSet(opts, nocache) {\r\n        function generateMask(mask, metadata, opts) {\r\n            if (null !== mask && \"\" !== mask) {\r\n                if (1 === mask.length && opts.greedy === !1 && 0 !== opts.repeat && (opts.placeholder = \"\"), \r\n                opts.repeat > 0 || \"*\" === opts.repeat || \"+\" === opts.repeat) {\r\n                    var repeatStart = \"*\" === opts.repeat ? 0 : \"+\" === opts.repeat ? 1 : opts.repeat;\r\n                    mask = opts.groupmarker.start + mask + opts.groupmarker.end + opts.quantifiermarker.start + repeatStart + \",\" + opts.repeat + opts.quantifiermarker.end;\r\n                }\r\n                var masksetDefinition;\r\n                return void 0 === Inputmask.prototype.masksCache[mask] || nocache === !0 ? (masksetDefinition = {\r\n                    mask: mask,\r\n                    maskToken: Inputmask.analyseMask(mask, opts),\r\n                    validPositions: {},\r\n                    _buffer: void 0,\r\n                    buffer: void 0,\r\n                    tests: {},\r\n                    metadata: metadata,\r\n                    maskLength: void 0\r\n                }, nocache !== !0 && (Inputmask.prototype.masksCache[opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask] = masksetDefinition, \r\n                masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask]))) : masksetDefinition = $.extend(!0, {}, Inputmask.prototype.masksCache[opts.numericInput ? mask.split(\"\").reverse().join(\"\") : mask]), \r\n                masksetDefinition;\r\n            }\r\n        }\r\n        var ms;\r\n        if ($.isFunction(opts.mask) && (opts.mask = opts.mask(opts)), $.isArray(opts.mask)) {\r\n            if (opts.mask.length > 1) {\r\n                opts.keepStatic = null === opts.keepStatic || opts.keepStatic;\r\n                var altMask = opts.groupmarker.start;\r\n                return $.each(opts.numericInput ? opts.mask.reverse() : opts.mask, function(ndx, msk) {\r\n                    altMask.length > 1 && (altMask += opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start), \r\n                    altMask += void 0 === msk.mask || $.isFunction(msk.mask) ? msk : msk.mask;\r\n                }), altMask += opts.groupmarker.end, generateMask(altMask, opts.mask, opts);\r\n            }\r\n            opts.mask = opts.mask.pop();\r\n        }\r\n        return opts.mask && (ms = void 0 === opts.mask.mask || $.isFunction(opts.mask.mask) ? generateMask(opts.mask, opts.mask, opts) : generateMask(opts.mask.mask, opts.mask, opts)), \r\n        ms;\r\n    }\r\n    function maskScope(actionObj, maskset, opts) {\r\n        function getMaskTemplate(baseOnInput, minimalPos, includeInput) {\r\n            minimalPos = minimalPos || 0;\r\n            var ndxIntlzr, test, testPos, maskTemplate = [], pos = 0, lvp = getLastValidPosition();\r\n            maxLength = void 0 !== el ? el.maxLength : void 0, maxLength === -1 && (maxLength = void 0);\r\n            do baseOnInput === !0 && getMaskSet().validPositions[pos] ? (testPos = getMaskSet().validPositions[pos], \r\n            test = testPos.match, ndxIntlzr = testPos.locator.slice(), maskTemplate.push(includeInput === !0 ? testPos.input : getPlaceholder(pos, test))) : (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), \r\n            test = testPos.match, ndxIntlzr = testPos.locator.slice(), (opts.jitMasking === !1 || pos < lvp || Number.isFinite(opts.jitMasking) && opts.jitMasking > pos) && maskTemplate.push(getPlaceholder(pos, test))), \r\n            pos++; while ((void 0 === maxLength || pos < maxLength) && (null !== test.fn || \"\" !== test.def) || minimalPos > pos);\r\n            return \"\" === maskTemplate[maskTemplate.length - 1] && maskTemplate.pop(), getMaskSet().maskLength = pos + 1, \r\n            maskTemplate;\r\n        }\r\n        function getMaskSet() {\r\n            return maskset;\r\n        }\r\n        function resetMaskSet(soft) {\r\n            var maskset = getMaskSet();\r\n            maskset.buffer = void 0, soft !== !0 && (maskset._buffer = void 0, maskset.validPositions = {}, \r\n            maskset.p = 0);\r\n        }\r\n        function getLastValidPosition(closestTo, strict, validPositions) {\r\n            var before = -1, after = -1, valids = validPositions || getMaskSet().validPositions;\r\n            void 0 === closestTo && (closestTo = -1);\r\n            for (var posNdx in valids) {\r\n                var psNdx = parseInt(posNdx);\r\n                valids[psNdx] && (strict || null !== valids[psNdx].match.fn) && (psNdx <= closestTo && (before = psNdx), \r\n                psNdx >= closestTo && (after = psNdx));\r\n            }\r\n            return before !== -1 && closestTo - before > 1 || after < closestTo ? before : after;\r\n        }\r\n        function stripValidPositions(start, end, nocheck, strict) {\r\n            function IsEnclosedStatic(pos) {\r\n                var posMatch = getMaskSet().validPositions[pos];\r\n                if (void 0 !== posMatch && null === posMatch.match.fn) {\r\n                    var prevMatch = getMaskSet().validPositions[pos - 1], nextMatch = getMaskSet().validPositions[pos + 1];\r\n                    return void 0 !== prevMatch && void 0 !== nextMatch;\r\n                }\r\n                return !1;\r\n            }\r\n            var i, startPos = start, positionsClone = $.extend(!0, {}, getMaskSet().validPositions), needsValidation = !1;\r\n            for (getMaskSet().p = start, i = end - 1; i >= startPos; i--) void 0 !== getMaskSet().validPositions[i] && (nocheck !== !0 && (!getMaskSet().validPositions[i].match.optionality && IsEnclosedStatic(i) || opts.canClearPosition(getMaskSet(), i, getLastValidPosition(), strict, opts) === !1) || delete getMaskSet().validPositions[i]);\r\n            for (resetMaskSet(!0), i = startPos + 1; i <= getLastValidPosition(); ) {\r\n                for (;void 0 !== getMaskSet().validPositions[startPos]; ) startPos++;\r\n                var s = getMaskSet().validPositions[startPos];\r\n                if (i < startPos && (i = startPos + 1), void 0 === getMaskSet().validPositions[i] && isMask(i) || void 0 !== s) i++; else {\r\n                    var t = getTestTemplate(i);\r\n                    needsValidation === !1 && positionsClone[startPos] && positionsClone[startPos].match.def === t.match.def ? (getMaskSet().validPositions[startPos] = $.extend(!0, {}, positionsClone[startPos]), \r\n                    getMaskSet().validPositions[startPos].input = t.input, delete getMaskSet().validPositions[i], \r\n                    i++) : positionCanMatchDefinition(startPos, t.match.def) ? isValid(startPos, t.input || getPlaceholder(i), !0) !== !1 && (delete getMaskSet().validPositions[i], \r\n                    i++, needsValidation = !0) : isMask(i) || (i++, startPos--), startPos++;\r\n                }\r\n            }\r\n            resetMaskSet(!0);\r\n        }\r\n        function determineTestTemplate(tests, guessNextBest) {\r\n            for (var testPos, testPositions = tests, lvp = getLastValidPosition(), lvTest = getMaskSet().validPositions[lvp] || getTests(0)[0], lvTestAltArr = void 0 !== lvTest.alternation ? lvTest.locator[lvTest.alternation].toString().split(\",\") : [], ndx = 0; ndx < testPositions.length && (testPos = testPositions[ndx], \r\n            !(testPos.match && (opts.greedy && testPos.match.optionalQuantifier !== !0 || (testPos.match.optionality === !1 || testPos.match.newBlockMarker === !1) && testPos.match.optionalQuantifier !== !0) && (void 0 === lvTest.alternation || lvTest.alternation !== testPos.alternation || void 0 !== testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAltArr))) || guessNextBest === !0 && (null !== testPos.match.fn || /[0-9a-bA-Z]/.test(testPos.match.def))); ndx++) ;\r\n            return testPos;\r\n        }\r\n        function getTestTemplate(pos, ndxIntlzr, tstPs) {\r\n            return getMaskSet().validPositions[pos] || determineTestTemplate(getTests(pos, ndxIntlzr ? ndxIntlzr.slice() : ndxIntlzr, tstPs));\r\n        }\r\n        function getTest(pos) {\r\n            return getMaskSet().validPositions[pos] ? getMaskSet().validPositions[pos] : getTests(pos)[0];\r\n        }\r\n        function positionCanMatchDefinition(pos, def) {\r\n            for (var valid = !1, tests = getTests(pos), tndx = 0; tndx < tests.length; tndx++) if (tests[tndx].match && tests[tndx].match.def === def) {\r\n                valid = !0;\r\n                break;\r\n            }\r\n            return valid;\r\n        }\r\n        function selectBestMatch(pos, alternateNdx) {\r\n            var bestMatch, indexPos;\r\n            return (getMaskSet().tests[pos] || getMaskSet().validPositions[pos]) && $.each(getMaskSet().tests[pos] || [ getMaskSet().validPositions[pos] ], function(ndx, lmnt) {\r\n                var ndxPos = lmnt.alternation ? lmnt.locator[lmnt.alternation].toString().indexOf(alternateNdx) : -1;\r\n                (void 0 === indexPos || ndxPos < indexPos) && ndxPos !== -1 && (bestMatch = lmnt, \r\n                indexPos = ndxPos);\r\n            }), bestMatch;\r\n        }\r\n        function getTests(pos, ndxIntlzr, tstPs) {\r\n            function resolveTestFromToken(maskToken, ndxInitializer, loopNdx, quantifierRecurse) {\r\n                function handleMatch(match, loopNdx, quantifierRecurse) {\r\n                    function isFirstMatch(latestMatch, tokenGroup) {\r\n                        var firstMatch = 0 === $.inArray(latestMatch, tokenGroup.matches);\r\n                        return firstMatch || $.each(tokenGroup.matches, function(ndx, match) {\r\n                            if (match.isQuantifier === !0 && (firstMatch = isFirstMatch(latestMatch, tokenGroup.matches[ndx - 1]))) return !1;\r\n                        }), firstMatch;\r\n                    }\r\n                    function resolveNdxInitializer(pos, alternateNdx) {\r\n                        var bestMatch = selectBestMatch(pos, alternateNdx);\r\n                        return bestMatch ? bestMatch.locator.slice(bestMatch.alternation + 1) : void 0;\r\n                    }\r\n                    function staticCanMatchDefinition(source, target) {\r\n                        return null === source.match.fn && null !== target.match.fn && target.match.fn.test(source.match.def, getMaskSet(), pos, !1, opts, !1);\r\n                    }\r\n                    if (testPos > 1e4) throw \"Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. \" + getMaskSet().mask;\r\n                    if (testPos === pos && void 0 === match.matches) return matches.push({\r\n                        match: match,\r\n                        locator: loopNdx.reverse(),\r\n                        cd: cacheDependency\r\n                    }), !0;\r\n                    if (void 0 !== match.matches) {\r\n                        if (match.isGroup && quantifierRecurse !== match) {\r\n                            if (match = handleMatch(maskToken.matches[$.inArray(match, maskToken.matches) + 1], loopNdx)) return !0;\r\n                        } else if (match.isOptional) {\r\n                            var optionalToken = match;\r\n                            if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) {\r\n                                if (latestMatch = matches[matches.length - 1].match, !isFirstMatch(latestMatch, optionalToken)) return !0;\r\n                                insertStop = !0, testPos = pos;\r\n                            }\r\n                        } else if (match.isAlternator) {\r\n                            var maltMatches, alternateToken = match, malternateMatches = [], currentMatches = matches.slice(), loopNdxCnt = loopNdx.length, altIndex = ndxInitializer.length > 0 ? ndxInitializer.shift() : -1;\r\n                            if (altIndex === -1 || \"string\" == typeof altIndex) {\r\n                                var amndx, currentPos = testPos, ndxInitializerClone = ndxInitializer.slice(), altIndexArr = [];\r\n                                if (\"string\" == typeof altIndex) altIndexArr = altIndex.split(\",\"); else for (amndx = 0; amndx < alternateToken.matches.length; amndx++) altIndexArr.push(amndx);\r\n                                for (var ndx = 0; ndx < altIndexArr.length; ndx++) {\r\n                                    if (amndx = parseInt(altIndexArr[ndx]), matches = [], ndxInitializer = resolveNdxInitializer(testPos, amndx) || ndxInitializerClone.slice(), \r\n                                    match = handleMatch(alternateToken.matches[amndx] || maskToken.matches[amndx], [ amndx ].concat(loopNdx), quantifierRecurse) || match, \r\n                                    match !== !0 && void 0 !== match && altIndexArr[altIndexArr.length - 1] < alternateToken.matches.length) {\r\n                                        var ntndx = $.inArray(match, maskToken.matches) + 1;\r\n                                        maskToken.matches.length > ntndx && (match = handleMatch(maskToken.matches[ntndx], [ ntndx ].concat(loopNdx.slice(1, loopNdx.length)), quantifierRecurse), \r\n                                        match && (altIndexArr.push(ntndx.toString()), $.each(matches, function(ndx, lmnt) {\r\n                                            lmnt.alternation = loopNdx.length - 1;\r\n                                        })));\r\n                                    }\r\n                                    maltMatches = matches.slice(), testPos = currentPos, matches = [];\r\n                                    for (var ndx1 = 0; ndx1 < maltMatches.length; ndx1++) {\r\n                                        var altMatch = maltMatches[ndx1], hasMatch = !1;\r\n                                        altMatch.alternation = altMatch.alternation || loopNdxCnt;\r\n                                        for (var ndx2 = 0; ndx2 < malternateMatches.length; ndx2++) {\r\n                                            var altMatch2 = malternateMatches[ndx2];\r\n                                            if ((\"string\" != typeof altIndex || $.inArray(altMatch.locator[altMatch.alternation].toString(), altIndexArr) !== -1) && (altMatch.match.def === altMatch2.match.def || staticCanMatchDefinition(altMatch, altMatch2))) {\r\n                                                hasMatch = altMatch.match.nativeDef === altMatch2.match.nativeDef, altMatch2.locator[altMatch.alternation].toString().indexOf(altMatch.locator[altMatch.alternation]) === -1 && (altMatch2.locator[altMatch.alternation] = altMatch2.locator[altMatch.alternation] + \",\" + altMatch.locator[altMatch.alternation], \r\n                                                altMatch2.alternation = altMatch.alternation, null == altMatch.match.fn && (altMatch2.na = altMatch2.na || altMatch.locator[altMatch.alternation].toString(), \r\n                                                altMatch2.na.indexOf(altMatch.locator[altMatch.alternation]) === -1 && (altMatch2.na = altMatch2.na + \",\" + altMatch.locator[altMatch.alternation])));\r\n                                                break;\r\n                                            }\r\n                                        }\r\n                                        hasMatch || malternateMatches.push(altMatch);\r\n                                    }\r\n                                }\r\n                                \"string\" == typeof altIndex && (malternateMatches = $.map(malternateMatches, function(lmnt, ndx) {\r\n                                    if (isFinite(ndx)) {\r\n                                        var mamatch, alternation = lmnt.alternation, altLocArr = lmnt.locator[alternation].toString().split(\",\");\r\n                                        lmnt.locator[alternation] = void 0, lmnt.alternation = void 0;\r\n                                        for (var alndx = 0; alndx < altLocArr.length; alndx++) mamatch = $.inArray(altLocArr[alndx], altIndexArr) !== -1, \r\n                                        mamatch && (void 0 !== lmnt.locator[alternation] ? (lmnt.locator[alternation] += \",\", \r\n                                        lmnt.locator[alternation] += altLocArr[alndx]) : lmnt.locator[alternation] = parseInt(altLocArr[alndx]), \r\n                                        lmnt.alternation = alternation);\r\n                                        if (void 0 !== lmnt.locator[alternation]) return lmnt;\r\n                                    }\r\n                                })), matches = currentMatches.concat(malternateMatches), testPos = pos, insertStop = matches.length > 0, \r\n                                ndxInitializer = ndxInitializerClone.slice();\r\n                            } else match = handleMatch(alternateToken.matches[altIndex] || maskToken.matches[altIndex], [ altIndex ].concat(loopNdx), quantifierRecurse);\r\n                            if (match) return !0;\r\n                        } else if (match.isQuantifier && quantifierRecurse !== maskToken.matches[$.inArray(match, maskToken.matches) - 1]) for (var qt = match, qndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; qndx < (isNaN(qt.quantifier.max) ? qndx + 1 : qt.quantifier.max) && testPos <= pos; qndx++) {\r\n                            var tokenGroup = maskToken.matches[$.inArray(qt, maskToken.matches) - 1];\r\n                            if (match = handleMatch(tokenGroup, [ qndx ].concat(loopNdx), tokenGroup)) {\r\n                                if (latestMatch = matches[matches.length - 1].match, latestMatch.optionalQuantifier = qndx > qt.quantifier.min - 1, \r\n                                isFirstMatch(latestMatch, tokenGroup)) {\r\n                                    if (qndx > qt.quantifier.min - 1) {\r\n                                        insertStop = !0, testPos = pos;\r\n                                        break;\r\n                                    }\r\n                                    return !0;\r\n                                }\r\n                                return !0;\r\n                            }\r\n                        } else if (match = resolveTestFromToken(match, ndxInitializer, loopNdx, quantifierRecurse)) return !0;\r\n                    } else testPos++;\r\n                }\r\n                for (var tndx = ndxInitializer.length > 0 ? ndxInitializer.shift() : 0; tndx < maskToken.matches.length; tndx++) if (maskToken.matches[tndx].isQuantifier !== !0) {\r\n                    var match = handleMatch(maskToken.matches[tndx], [ tndx ].concat(loopNdx), quantifierRecurse);\r\n                    if (match && testPos === pos) return match;\r\n                    if (testPos > pos) break;\r\n                }\r\n            }\r\n            function mergeLocators(tests) {\r\n                var locator = [];\r\n                return $.isArray(tests) || (tests = [ tests ]), tests.length > 0 && (void 0 === tests[0].alternation ? (locator = determineTestTemplate(tests.slice()).locator.slice(), \r\n                0 === locator.length && (locator = tests[0].locator.slice())) : $.each(tests, function(ndx, tst) {\r\n                    if (\"\" !== tst.def) if (0 === locator.length) locator = tst.locator.slice(); else for (var i = 0; i < locator.length; i++) tst.locator[i] && locator[i].toString().indexOf(tst.locator[i]) === -1 && (locator[i] += \",\" + tst.locator[i]);\r\n                })), locator;\r\n            }\r\n            function filterTests(tests) {\r\n                return opts.keepStatic && pos > 0 && tests.length > 1 + (\"\" === tests[tests.length - 1].match.def ? 1 : 0) && tests[0].match.optionality !== !0 && tests[0].match.optionalQuantifier !== !0 && null === tests[0].match.fn && !/[0-9a-bA-Z]/.test(tests[0].match.def) ? [ determineTestTemplate(tests) ] : tests;\r\n            }\r\n            var latestMatch, maskTokens = getMaskSet().maskToken, testPos = ndxIntlzr ? tstPs : 0, ndxInitializer = ndxIntlzr ? ndxIntlzr.slice() : [ 0 ], matches = [], insertStop = !1, cacheDependency = ndxIntlzr ? ndxIntlzr.join(\"\") : \"\";\r\n            if (pos > -1) {\r\n                if (void 0 === ndxIntlzr) {\r\n                    for (var test, previousPos = pos - 1; void 0 === (test = getMaskSet().validPositions[previousPos] || getMaskSet().tests[previousPos]) && previousPos > -1; ) previousPos--;\r\n                    void 0 !== test && previousPos > -1 && (ndxInitializer = mergeLocators(test), cacheDependency = ndxInitializer.join(\"\"), \r\n                    testPos = previousPos);\r\n                }\r\n                if (getMaskSet().tests[pos] && getMaskSet().tests[pos][0].cd === cacheDependency) return filterTests(getMaskSet().tests[pos]);\r\n                for (var mtndx = ndxInitializer.shift(); mtndx < maskTokens.length; mtndx++) {\r\n                    var match = resolveTestFromToken(maskTokens[mtndx], ndxInitializer, [ mtndx ]);\r\n                    if (match && testPos === pos || testPos > pos) break;\r\n                }\r\n            }\r\n            return (0 === matches.length || insertStop) && matches.push({\r\n                match: {\r\n                    fn: null,\r\n                    cardinality: 0,\r\n                    optionality: !0,\r\n                    casing: null,\r\n                    def: \"\",\r\n                    placeholder: \"\"\r\n                },\r\n                locator: [],\r\n                cd: cacheDependency\r\n            }), void 0 !== ndxIntlzr && getMaskSet().tests[pos] ? filterTests($.extend(!0, [], matches)) : (getMaskSet().tests[pos] = $.extend(!0, [], matches), \r\n            filterTests(getMaskSet().tests[pos]));\r\n        }\r\n        function getBufferTemplate() {\r\n            return void 0 === getMaskSet()._buffer && (getMaskSet()._buffer = getMaskTemplate(!1, 1), \r\n            void 0 === getMaskSet().buffer && getMaskSet()._buffer.slice()), getMaskSet()._buffer;\r\n        }\r\n        function getBuffer(noCache) {\r\n            return void 0 !== getMaskSet().buffer && noCache !== !0 || (getMaskSet().buffer = getMaskTemplate(!0, getLastValidPosition(), !0)), \r\n            getMaskSet().buffer;\r\n        }\r\n        function refreshFromBuffer(start, end, buffer) {\r\n            var i;\r\n            if (start === !0) resetMaskSet(), start = 0, end = buffer.length; else for (i = start; i < end; i++) delete getMaskSet().validPositions[i];\r\n            for (i = start; i < end; i++) resetMaskSet(!0), buffer[i] !== opts.skipOptionalPartCharacter && isValid(i, buffer[i], !0, !0);\r\n        }\r\n        function casing(elem, test, pos) {\r\n            switch (opts.casing || test.casing) {\r\n              case \"upper\":\r\n                elem = elem.toUpperCase();\r\n                break;\r\n\r\n              case \"lower\":\r\n                elem = elem.toLowerCase();\r\n                break;\r\n\r\n              case \"title\":\r\n                var posBefore = getMaskSet().validPositions[pos - 1];\r\n                elem = 0 === pos || posBefore && posBefore.input === String.fromCharCode(Inputmask.keyCode.SPACE) ? elem.toUpperCase() : elem.toLowerCase();\r\n            }\r\n            return elem;\r\n        }\r\n        function checkAlternationMatch(altArr1, altArr2) {\r\n            for (var altArrC = opts.greedy ? altArr2 : altArr2.slice(0, 1), isMatch = !1, alndx = 0; alndx < altArr1.length; alndx++) if ($.inArray(altArr1[alndx], altArrC) !== -1) {\r\n                isMatch = !0;\r\n                break;\r\n            }\r\n            return isMatch;\r\n        }\r\n        function isValid(pos, c, strict, fromSetValid, fromAlternate) {\r\n            function isSelection(posObj) {\r\n                var selection = isRTL ? posObj.begin - posObj.end > 1 || posObj.begin - posObj.end === 1 && opts.insertMode : posObj.end - posObj.begin > 1 || posObj.end - posObj.begin === 1 && opts.insertMode;\r\n                return selection && 0 === posObj.begin && posObj.end === getMaskSet().maskLength ? \"full\" : selection;\r\n            }\r\n            function _isValid(position, c, strict) {\r\n                var rslt = !1;\r\n                return $.each(getTests(position), function(ndx, tst) {\r\n                    for (var test = tst.match, loopend = c ? 1 : 0, chrs = \"\", i = test.cardinality; i > loopend; i--) chrs += getBufferElement(position - (i - 1));\r\n                    if (c && (chrs += c), getBuffer(!0), rslt = null != test.fn ? test.fn.test(chrs, getMaskSet(), position, strict, opts, isSelection(pos)) : (c === test.def || c === opts.skipOptionalPartCharacter) && \"\" !== test.def && {\r\n                        c: test.placeholder || test.def,\r\n                        pos: position\r\n                    }, rslt !== !1) {\r\n                        var elem = void 0 !== rslt.c ? rslt.c : c;\r\n                        elem = elem === opts.skipOptionalPartCharacter && null === test.fn ? test.placeholder || test.def : elem;\r\n                        var validatedPos = position, possibleModifiedBuffer = getBuffer();\r\n                        if (void 0 !== rslt.remove && ($.isArray(rslt.remove) || (rslt.remove = [ rslt.remove ]), \r\n                        $.each(rslt.remove.sort(function(a, b) {\r\n                            return b - a;\r\n                        }), function(ndx, lmnt) {\r\n                            stripValidPositions(lmnt, lmnt + 1, !0);\r\n                        })), void 0 !== rslt.insert && ($.isArray(rslt.insert) || (rslt.insert = [ rslt.insert ]), \r\n                        $.each(rslt.insert.sort(function(a, b) {\r\n                            return a - b;\r\n                        }), function(ndx, lmnt) {\r\n                            isValid(lmnt.pos, lmnt.c, !0, fromSetValid);\r\n                        })), rslt.refreshFromBuffer) {\r\n                            var refresh = rslt.refreshFromBuffer;\r\n                            if (strict = !0, refreshFromBuffer(refresh === !0 ? refresh : refresh.start, refresh.end, possibleModifiedBuffer), \r\n                            void 0 === rslt.pos && void 0 === rslt.c) return rslt.pos = getLastValidPosition(), \r\n                            !1;\r\n                            if (validatedPos = void 0 !== rslt.pos ? rslt.pos : position, validatedPos !== position) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0, fromSetValid)), \r\n                            !1;\r\n                        } else if (rslt !== !0 && void 0 !== rslt.pos && rslt.pos !== position && (validatedPos = rslt.pos, \r\n                        refreshFromBuffer(position, validatedPos, getBuffer().slice()), validatedPos !== position)) return rslt = $.extend(rslt, isValid(validatedPos, elem, !0)), \r\n                        !1;\r\n                        return (rslt === !0 || void 0 !== rslt.pos || void 0 !== rslt.c) && (ndx > 0 && resetMaskSet(!0), \r\n                        setValidPosition(validatedPos, $.extend({}, tst, {\r\n                            input: casing(elem, test, validatedPos)\r\n                        }), fromSetValid, isSelection(pos)) || (rslt = !1), !1);\r\n                    }\r\n                }), rslt;\r\n            }\r\n            function alternate(pos, c, strict) {\r\n                var lastAlt, alternation, altPos, prevAltPos, i, validPos, altNdxs, decisionPos, validPsClone = $.extend(!0, {}, getMaskSet().validPositions), isValidRslt = !1, lAltPos = getLastValidPosition();\r\n                for (prevAltPos = getMaskSet().validPositions[lAltPos]; lAltPos >= 0; lAltPos--) if (altPos = getMaskSet().validPositions[lAltPos], \r\n                altPos && void 0 !== altPos.alternation) {\r\n                    if (lastAlt = lAltPos, alternation = getMaskSet().validPositions[lastAlt].alternation, \r\n                    prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) break;\r\n                    prevAltPos = altPos;\r\n                }\r\n                if (void 0 !== alternation) {\r\n                    decisionPos = parseInt(lastAlt);\r\n                    var decisionTaker = void 0 !== prevAltPos.locator[prevAltPos.alternation || alternation] ? prevAltPos.locator[prevAltPos.alternation || alternation] : altNdxs[0];\r\n                    decisionTaker.length > 0 && (decisionTaker = decisionTaker.split(\",\")[0]);\r\n                    var possibilityPos = getMaskSet().validPositions[decisionPos], prevPos = getMaskSet().validPositions[decisionPos - 1];\r\n                    $.each(getTests(decisionPos, prevPos ? prevPos.locator : void 0, decisionPos - 1), function(ndx, test) {\r\n                        altNdxs = test.locator[alternation] ? test.locator[alternation].toString().split(\",\") : [];\r\n                        for (var mndx = 0; mndx < altNdxs.length; mndx++) {\r\n                            var validInputs = [], staticInputsBeforePos = 0, staticInputsBeforePosAlternate = 0, verifyValidInput = !1;\r\n                            if (decisionTaker < altNdxs[mndx] && (void 0 === test.na || $.inArray(altNdxs[mndx], test.na.split(\",\")) === -1)) {\r\n                                getMaskSet().validPositions[decisionPos] = $.extend(!0, {}, test);\r\n                                var possibilities = getMaskSet().validPositions[decisionPos].locator;\r\n                                for (getMaskSet().validPositions[decisionPos].locator[alternation] = parseInt(altNdxs[mndx]), \r\n                                null == test.match.fn ? (possibilityPos.input !== test.match.def && (verifyValidInput = !0, \r\n                                possibilityPos.generatedInput !== !0 && validInputs.push(possibilityPos.input)), \r\n                                staticInputsBeforePosAlternate++, getMaskSet().validPositions[decisionPos].generatedInput = !/[0-9a-bA-Z]/.test(test.match.def), \r\n                                getMaskSet().validPositions[decisionPos].input = test.match.def) : getMaskSet().validPositions[decisionPos].input = possibilityPos.input, \r\n                                i = decisionPos + 1; i < getLastValidPosition(void 0, !0) + 1; i++) validPos = getMaskSet().validPositions[i], \r\n                                validPos && validPos.generatedInput !== !0 && /[0-9a-bA-Z]/.test(validPos.input) ? validInputs.push(validPos.input) : i < pos && staticInputsBeforePos++, \r\n                                delete getMaskSet().validPositions[i];\r\n                                for (verifyValidInput && validInputs[0] === test.match.def && validInputs.shift(), \r\n                                resetMaskSet(!0), isValidRslt = !0; validInputs.length > 0; ) {\r\n                                    var input = validInputs.shift();\r\n                                    if (input !== opts.skipOptionalPartCharacter && !(isValidRslt = isValid(getLastValidPosition(void 0, !0) + 1, input, !1, fromSetValid, !0))) break;\r\n                                }\r\n                                if (isValidRslt) {\r\n                                    getMaskSet().validPositions[decisionPos].locator = possibilities;\r\n                                    var targetLvp = getLastValidPosition(pos) + 1;\r\n                                    for (i = decisionPos + 1; i < getLastValidPosition() + 1; i++) validPos = getMaskSet().validPositions[i], \r\n                                    (void 0 === validPos || null == validPos.match.fn) && i < pos + (staticInputsBeforePosAlternate - staticInputsBeforePos) && staticInputsBeforePosAlternate++;\r\n                                    pos += staticInputsBeforePosAlternate - staticInputsBeforePos, isValidRslt = isValid(pos > targetLvp ? targetLvp : pos, c, strict, fromSetValid, !0);\r\n                                }\r\n                                if (isValidRslt) return !1;\r\n                                resetMaskSet(), getMaskSet().validPositions = $.extend(!0, {}, validPsClone);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                return isValidRslt;\r\n            }\r\n            function trackbackAlternations(originalPos, newPos) {\r\n                var vp = getMaskSet().validPositions[newPos];\r\n                if (vp) for (var targetLocator = vp.locator, tll = targetLocator.length, ps = originalPos; ps < newPos; ps++) if (void 0 === getMaskSet().validPositions[ps] && !isMask(ps, !0)) {\r\n                    var tests = getTests(ps), bestMatch = tests[0], equality = -1;\r\n                    $.each(tests, function(ndx, tst) {\r\n                        for (var i = 0; i < tll && (void 0 !== tst.locator[i] && checkAlternationMatch(tst.locator[i].toString().split(\",\"), targetLocator[i].toString().split(\",\"))); i++) equality < i && (equality = i, \r\n                        bestMatch = tst);\r\n                    }), setValidPosition(ps, $.extend({}, bestMatch, {\r\n                        input: bestMatch.match.placeholder || bestMatch.match.def\r\n                    }), !0);\r\n                }\r\n            }\r\n            function setValidPosition(pos, validTest, fromSetValid, isSelection) {\r\n                if (isSelection || opts.insertMode && void 0 !== getMaskSet().validPositions[pos] && void 0 === fromSetValid) {\r\n                    var i, positionsClone = $.extend(!0, {}, getMaskSet().validPositions), lvp = getLastValidPosition(void 0, !0);\r\n                    for (i = pos; i <= lvp; i++) delete getMaskSet().validPositions[i];\r\n                    getMaskSet().validPositions[pos] = $.extend(!0, {}, validTest);\r\n                    var j, valid = !0, vps = getMaskSet().validPositions, needsValidation = !1, initialLength = getMaskSet().maskLength;\r\n                    for (i = j = pos; i <= lvp; i++) {\r\n                        var t = positionsClone[i];\r\n                        if (void 0 !== t) for (var posMatch = j; posMatch < getMaskSet().maskLength && (null == t.match.fn && vps[i] && (vps[i].match.optionalQuantifier === !0 || vps[i].match.optionality === !0) || null != t.match.fn); ) {\r\n                            if (posMatch++, needsValidation === !1 && positionsClone[posMatch] && positionsClone[posMatch].match.def === t.match.def) getMaskSet().validPositions[posMatch] = $.extend(!0, {}, positionsClone[posMatch]), \r\n                            getMaskSet().validPositions[posMatch].input = t.input, fillMissingNonMask(posMatch), \r\n                            j = posMatch, valid = !0; else if (positionCanMatchDefinition(posMatch, t.match.def)) {\r\n                                var result = isValid(posMatch, t.input, !0, !0);\r\n                                valid = result !== !1, j = result.caret || result.insert ? getLastValidPosition() : posMatch, \r\n                                needsValidation = !0;\r\n                            } else valid = t.generatedInput === !0;\r\n                            if (getMaskSet().maskLength < initialLength && (getMaskSet().maskLength = initialLength), \r\n                            valid) break;\r\n                        }\r\n                        if (!valid) break;\r\n                    }\r\n                    if (!valid) return getMaskSet().validPositions = $.extend(!0, {}, positionsClone), \r\n                    resetMaskSet(!0), !1;\r\n                } else getMaskSet().validPositions[pos] = $.extend(!0, {}, validTest);\r\n                return resetMaskSet(!0), !0;\r\n            }\r\n            function fillMissingNonMask(maskPos) {\r\n                for (var pndx = maskPos - 1; pndx > -1 && !getMaskSet().validPositions[pndx]; pndx--) ;\r\n                var testTemplate, testsFromPos;\r\n                for (pndx++; pndx < maskPos; pndx++) void 0 === getMaskSet().validPositions[pndx] && (opts.jitMasking === !1 || opts.jitMasking > pndx) && (testsFromPos = getTests(pndx, getTestTemplate(pndx - 1).locator, pndx - 1).slice(), \r\n                \"\" === testsFromPos[testsFromPos.length - 1].match.def && testsFromPos.pop(), testTemplate = determineTestTemplate(testsFromPos), \r\n                testTemplate && (testTemplate.match.def === opts.radixPointDefinitionSymbol || !isMask(pndx, !0) || $.inArray(opts.radixPoint, getBuffer()) < pndx && testTemplate.match.fn && testTemplate.match.fn.test(getPlaceholder(pndx), getMaskSet(), pndx, !1, opts)) && (result = _isValid(pndx, testTemplate.match.placeholder || (null == testTemplate.match.fn ? testTemplate.match.def : \"\" !== getPlaceholder(pndx) ? getPlaceholder(pndx) : getBuffer()[pndx]), !0), \r\n                result !== !1 && (getMaskSet().validPositions[result.pos || pndx].generatedInput = !0)));\r\n            }\r\n            strict = strict === !0;\r\n            var maskPos = pos;\r\n            void 0 !== pos.begin && (maskPos = isRTL && !isSelection(pos) ? pos.end : pos.begin);\r\n            var result = !1, positionsClone = $.extend(!0, {}, getMaskSet().validPositions);\r\n            if (fillMissingNonMask(maskPos), isSelection(pos) && (handleRemove(void 0, Inputmask.keyCode.DELETE, pos), \r\n            maskPos = getMaskSet().p), maskPos < getMaskSet().maskLength && (result = _isValid(maskPos, c, strict), \r\n            (!strict || fromSetValid === !0) && result === !1)) {\r\n                var currentPosValid = getMaskSet().validPositions[maskPos];\r\n                if (!currentPosValid || null !== currentPosValid.match.fn || currentPosValid.match.def !== c && c !== opts.skipOptionalPartCharacter) {\r\n                    if ((opts.insertMode || void 0 === getMaskSet().validPositions[seekNext(maskPos)]) && !isMask(maskPos, !0)) {\r\n                        var testsFromPos = getTests(maskPos).slice();\r\n                        \"\" === testsFromPos[testsFromPos.length - 1].match.def && testsFromPos.pop();\r\n                        var staticChar = determineTestTemplate(testsFromPos, !0);\r\n                        staticChar && null === staticChar.match.fn && (staticChar = staticChar.match.placeholder || staticChar.match.def, \r\n                        _isValid(maskPos, staticChar, strict), getMaskSet().validPositions[maskPos].generatedInput = !0);\r\n                        for (var nPos = maskPos + 1, snPos = seekNext(maskPos); nPos <= snPos; nPos++) if (result = _isValid(nPos, c, strict), \r\n                        result !== !1) {\r\n                            trackbackAlternations(maskPos, void 0 !== result.pos ? result.pos : nPos), maskPos = nPos;\r\n                            break;\r\n                        }\r\n                    }\r\n                } else result = {\r\n                    caret: seekNext(maskPos)\r\n                };\r\n            }\r\n            return result === !1 && opts.keepStatic && !strict && fromAlternate !== !0 && (result = alternate(maskPos, c, strict)), \r\n            result === !0 && (result = {\r\n                pos: maskPos\r\n            }), $.isFunction(opts.postValidation) && result !== !1 && !strict && fromSetValid !== !0 && (result = !!opts.postValidation(getBuffer(!0), result, opts) && result), \r\n            void 0 === result.pos && (result.pos = maskPos), result === !1 && (resetMaskSet(!0), \r\n            getMaskSet().validPositions = $.extend(!0, {}, positionsClone)), result;\r\n        }\r\n        function isMask(pos, strict) {\r\n            var test;\r\n            if (strict ? (test = getTestTemplate(pos).match, \"\" === test.def && (test = getTest(pos).match)) : test = getTest(pos).match, \r\n            null != test.fn) return test.fn;\r\n            if (strict !== !0 && pos > -1) {\r\n                var tests = getTests(pos);\r\n                return tests.length > 1 + (\"\" === tests[tests.length - 1].match.def ? 1 : 0);\r\n            }\r\n            return !1;\r\n        }\r\n        function seekNext(pos, newBlock) {\r\n            var maskL = getMaskSet().maskLength;\r\n            if (pos >= maskL) return maskL;\r\n            for (var position = pos; ++position < maskL && (newBlock === !0 && (getTest(position).match.newBlockMarker !== !0 || !isMask(position)) || newBlock !== !0 && !isMask(position)); ) ;\r\n            return position;\r\n        }\r\n        function seekPrevious(pos, newBlock) {\r\n            var tests, position = pos;\r\n            if (position <= 0) return 0;\r\n            for (;--position > 0 && (newBlock === !0 && getTest(position).match.newBlockMarker !== !0 || newBlock !== !0 && !isMask(position) && (tests = getTests(position), \r\n            tests.length < 2 || 2 === tests.length && \"\" === tests[1].match.def)); ) ;\r\n            return position;\r\n        }\r\n        function getBufferElement(position) {\r\n            return void 0 === getMaskSet().validPositions[position] ? getPlaceholder(position) : getMaskSet().validPositions[position].input;\r\n        }\r\n        function writeBuffer(input, buffer, caretPos, event, triggerInputEvent) {\r\n            if (event && $.isFunction(opts.onBeforeWrite)) {\r\n                var result = opts.onBeforeWrite(event, buffer, caretPos, opts);\r\n                if (result) {\r\n                    if (result.refreshFromBuffer) {\r\n                        var refresh = result.refreshFromBuffer;\r\n                        refreshFromBuffer(refresh === !0 ? refresh : refresh.start, refresh.end, result.buffer || buffer), \r\n                        buffer = getBuffer(!0);\r\n                    }\r\n                    void 0 !== caretPos && (caretPos = void 0 !== result.caret ? result.caret : caretPos);\r\n                }\r\n            }\r\n            input.inputmask._valueSet(buffer.join(\"\")), void 0 === caretPos || void 0 !== event && \"blur\" === event.type ? renderColorMask(input, buffer, caretPos) : caret(input, caretPos), \r\n            triggerInputEvent === !0 && (skipInputEvent = !0, $(input).trigger(\"input\"));\r\n        }\r\n        function getPlaceholder(pos, test) {\r\n            if (test = test || getTest(pos).match, void 0 !== test.placeholder) return test.placeholder;\r\n            if (null === test.fn) {\r\n                if (pos > -1 && void 0 === getMaskSet().validPositions[pos]) {\r\n                    var prevTest, tests = getTests(pos), staticAlternations = [];\r\n                    if (tests.length > 1 + (\"\" === tests[tests.length - 1].match.def ? 1 : 0)) for (var i = 0; i < tests.length; i++) if (tests[i].match.optionality !== !0 && tests[i].match.optionalQuantifier !== !0 && (null === tests[i].match.fn || void 0 === prevTest || tests[i].match.fn.test(prevTest.match.def, getMaskSet(), pos, !0, opts) !== !1) && (staticAlternations.push(tests[i]), \r\n                    null === tests[i].match.fn && (prevTest = tests[i]), staticAlternations.length > 1 && /[0-9a-bA-Z]/.test(staticAlternations[0].match.def))) return opts.placeholder.charAt(pos % opts.placeholder.length);\r\n                }\r\n                return test.def;\r\n            }\r\n            return opts.placeholder.charAt(pos % opts.placeholder.length);\r\n        }\r\n        function checkVal(input, writeOut, strict, nptvl, initiatingEvent, stickyCaret) {\r\n            function isTemplateMatch() {\r\n                var isMatch = !1, charCodeNdx = getBufferTemplate().slice(initialNdx, seekNext(initialNdx)).join(\"\").indexOf(charCodes);\r\n                if (charCodeNdx !== -1 && !isMask(initialNdx)) {\r\n                    isMatch = !0;\r\n                    for (var bufferTemplateArr = getBufferTemplate().slice(initialNdx, initialNdx + charCodeNdx), i = 0; i < bufferTemplateArr.length; i++) if (\" \" !== bufferTemplateArr[i]) {\r\n                        isMatch = !1;\r\n                        break;\r\n                    }\r\n                }\r\n                return isMatch;\r\n            }\r\n            var inputValue = nptvl.slice(), charCodes = \"\", initialNdx = 0, result = void 0;\r\n            if (resetMaskSet(), getMaskSet().p = seekNext(-1), !strict) if (opts.autoUnmask !== !0) {\r\n                var staticInput = getBufferTemplate().slice(0, seekNext(-1)).join(\"\"), matches = inputValue.join(\"\").match(new RegExp(\"^\" + Inputmask.escapeRegex(staticInput), \"g\"));\r\n                matches && matches.length > 0 && (inputValue.splice(0, matches.length * staticInput.length), \r\n                initialNdx = seekNext(initialNdx));\r\n            } else initialNdx = seekNext(initialNdx);\r\n            if ($.each(inputValue, function(ndx, charCode) {\r\n                if (void 0 !== charCode) {\r\n                    var keypress = new $.Event(\"keypress\");\r\n                    keypress.which = charCode.charCodeAt(0), charCodes += charCode;\r\n                    var lvp = getLastValidPosition(void 0, !0), lvTest = getMaskSet().validPositions[lvp], nextTest = getTestTemplate(lvp + 1, lvTest ? lvTest.locator.slice() : void 0, lvp);\r\n                    if (!isTemplateMatch() || strict || opts.autoUnmask) {\r\n                        var pos = strict ? ndx : null == nextTest.match.fn && nextTest.match.optionality && lvp + 1 < getMaskSet().p ? lvp + 1 : getMaskSet().p;\r\n                        result = keypressEvent.call(input, keypress, !0, !1, strict, pos), initialNdx = pos + 1, \r\n                        charCodes = \"\";\r\n                    } else result = keypressEvent.call(input, keypress, !0, !1, !0, lvp + 1);\r\n                    if (!strict && $.isFunction(opts.onBeforeWrite) && (result = opts.onBeforeWrite(keypress, getBuffer(), result.forwardPosition, opts), \r\n                    result && result.refreshFromBuffer)) {\r\n                        var refresh = result.refreshFromBuffer;\r\n                        refreshFromBuffer(refresh === !0 ? refresh : refresh.start, refresh.end, result.buffer), \r\n                        resetMaskSet(!0), result.caret && (getMaskSet().p = result.caret);\r\n                    }\r\n                }\r\n            }), writeOut) {\r\n                var caretPos = void 0, lvp = getLastValidPosition();\r\n                document.activeElement === input && (initiatingEvent || result) && (caretPos = caret(input).begin, \r\n                initiatingEvent && result === !1 && (caretPos = seekNext(getLastValidPosition(caretPos))), \r\n                result && stickyCaret !== !0 && (caretPos < lvp + 1 || lvp === -1) && (caretPos = opts.numericInput && void 0 === result.caret ? seekPrevious(result.forwardPosition) : result.forwardPosition)), \r\n                writeBuffer(input, getBuffer(), caretPos, initiatingEvent || new $.Event(\"checkval\"));\r\n            }\r\n        }\r\n        function unmaskedvalue(input) {\r\n            if (input && void 0 === input.inputmask) return input.value;\r\n            var umValue = [], vps = getMaskSet().validPositions;\r\n            for (var pndx in vps) vps[pndx].match && null != vps[pndx].match.fn && umValue.push(vps[pndx].input);\r\n            var unmaskedValue = 0 === umValue.length ? \"\" : (isRTL ? umValue.reverse() : umValue).join(\"\");\r\n            if ($.isFunction(opts.onUnMask)) {\r\n                var bufferValue = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join(\"\");\r\n                unmaskedValue = opts.onUnMask(bufferValue, unmaskedValue, opts) || unmaskedValue;\r\n            }\r\n            return unmaskedValue;\r\n        }\r\n        function caret(input, begin, end, notranslate) {\r\n            function translatePosition(pos) {\r\n                if (notranslate !== !0 && isRTL && \"number\" == typeof pos && (!opts.greedy || \"\" !== opts.placeholder)) {\r\n                    var bffrLght = getBuffer().join(\"\").length;\r\n                    pos = bffrLght - pos;\r\n                }\r\n                return pos;\r\n            }\r\n            var range;\r\n            if (\"number\" != typeof begin) return input.setSelectionRange ? (begin = input.selectionStart, \r\n            end = input.selectionEnd) : window.getSelection ? (range = window.getSelection().getRangeAt(0), \r\n            range.commonAncestorContainer.parentNode !== input && range.commonAncestorContainer !== input || (begin = range.startOffset, \r\n            end = range.endOffset)) : document.selection && document.selection.createRange && (range = document.selection.createRange(), \r\n            begin = 0 - range.duplicate().moveStart(\"character\", -input.inputmask._valueGet().length), \r\n            end = begin + range.text.length), {\r\n                begin: translatePosition(begin),\r\n                end: translatePosition(end)\r\n            };\r\n            begin = translatePosition(begin), end = translatePosition(end), end = \"number\" == typeof end ? end : begin;\r\n            var scrollCalc = parseInt(((input.ownerDocument.defaultView || window).getComputedStyle ? (input.ownerDocument.defaultView || window).getComputedStyle(input, null) : input.currentStyle).fontSize) * end;\r\n            if (input.scrollLeft = scrollCalc > input.scrollWidth ? scrollCalc : 0, mobile || opts.insertMode !== !1 || begin !== end || end++, \r\n            input.setSelectionRange) input.selectionStart = begin, input.selectionEnd = end; else if (window.getSelection) {\r\n                if (range = document.createRange(), void 0 === input.firstChild || null === input.firstChild) {\r\n                    var textNode = document.createTextNode(\"\");\r\n                    input.appendChild(textNode);\r\n                }\r\n                range.setStart(input.firstChild, begin < input.inputmask._valueGet().length ? begin : input.inputmask._valueGet().length), \r\n                range.setEnd(input.firstChild, end < input.inputmask._valueGet().length ? end : input.inputmask._valueGet().length), \r\n                range.collapse(!0);\r\n                var sel = window.getSelection();\r\n                sel.removeAllRanges(), sel.addRange(range);\r\n            } else input.createTextRange && (range = input.createTextRange(), range.collapse(!0), \r\n            range.moveEnd(\"character\", end), range.moveStart(\"character\", begin), range.select());\r\n            renderColorMask(input, void 0, {\r\n                begin: begin,\r\n                end: end\r\n            });\r\n        }\r\n        function determineLastRequiredPosition(returnDefinition) {\r\n            var pos, testPos, buffer = getBuffer(), bl = buffer.length, lvp = getLastValidPosition(), positions = {}, lvTest = getMaskSet().validPositions[lvp], ndxIntlzr = void 0 !== lvTest ? lvTest.locator.slice() : void 0;\r\n            for (pos = lvp + 1; pos < buffer.length; pos++) testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), \r\n            ndxIntlzr = testPos.locator.slice(), positions[pos] = $.extend(!0, {}, testPos);\r\n            var lvTestAlt = lvTest && void 0 !== lvTest.alternation ? lvTest.locator[lvTest.alternation] : void 0;\r\n            for (pos = bl - 1; pos > lvp && (testPos = positions[pos], (testPos.match.optionality || testPos.match.optionalQuantifier || lvTestAlt && (lvTestAlt !== positions[pos].locator[lvTest.alternation] && null != testPos.match.fn || null === testPos.match.fn && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(\",\"), lvTestAlt.toString().split(\",\")) && \"\" !== getTests(pos)[0].def)) && buffer[pos] === getPlaceholder(pos, testPos.match)); pos--) bl--;\r\n            return returnDefinition ? {\r\n                l: bl,\r\n                def: positions[bl] ? positions[bl].match : void 0\r\n            } : bl;\r\n        }\r\n        function clearOptionalTail(buffer) {\r\n            for (var rl = determineLastRequiredPosition(), lmib = buffer.length - 1; lmib > rl && !isMask(lmib); lmib--) ;\r\n            return buffer.splice(rl, lmib + 1 - rl), buffer;\r\n        }\r\n        function isComplete(buffer) {\r\n            if ($.isFunction(opts.isComplete)) return opts.isComplete(buffer, opts);\r\n            if (\"*\" !== opts.repeat) {\r\n                var complete = !1, lrp = determineLastRequiredPosition(!0), aml = seekPrevious(lrp.l);\r\n                if (void 0 === lrp.def || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {\r\n                    complete = !0;\r\n                    for (var i = 0; i <= aml; i++) {\r\n                        var test = getTestTemplate(i).match;\r\n                        if (null !== test.fn && void 0 === getMaskSet().validPositions[i] && test.optionality !== !0 && test.optionalQuantifier !== !0 || null === test.fn && buffer[i] !== getPlaceholder(i, test)) {\r\n                            complete = !1;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                return complete;\r\n            }\r\n        }\r\n        function patchValueProperty(npt) {\r\n            function patchValhook(type) {\r\n                if ($.valHooks && (void 0 === $.valHooks[type] || $.valHooks[type].inputmaskpatch !== !0)) {\r\n                    var valhookGet = $.valHooks[type] && $.valHooks[type].get ? $.valHooks[type].get : function(elem) {\r\n                        return elem.value;\r\n                    }, valhookSet = $.valHooks[type] && $.valHooks[type].set ? $.valHooks[type].set : function(elem, value) {\r\n                        return elem.value = value, elem;\r\n                    };\r\n                    $.valHooks[type] = {\r\n                        get: function(elem) {\r\n                            if (elem.inputmask) {\r\n                                if (elem.inputmask.opts.autoUnmask) return elem.inputmask.unmaskedvalue();\r\n                                var result = valhookGet(elem);\r\n                                return getLastValidPosition(void 0, void 0, elem.inputmask.maskset.validPositions) !== -1 || opts.nullable !== !0 ? result : \"\";\r\n                            }\r\n                            return valhookGet(elem);\r\n                        },\r\n                        set: function(elem, value) {\r\n                            var result, $elem = $(elem);\r\n                            return result = valhookSet(elem, value), elem.inputmask && $elem.trigger(\"setvalue\"), \r\n                            result;\r\n                        },\r\n                        inputmaskpatch: !0\r\n                    };\r\n                }\r\n            }\r\n            function getter() {\r\n                return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : getLastValidPosition() !== -1 || opts.nullable !== !0 ? document.activeElement === this && opts.clearMaskOnLostFocus ? (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join(\"\") : valueGet.call(this) : \"\" : valueGet.call(this);\r\n            }\r\n            function setter(value) {\r\n                valueSet.call(this, value), this.inputmask && $(this).trigger(\"setvalue\");\r\n            }\r\n            function installNativeValueSetFallback(npt) {\r\n                EventRuler.on(npt, \"mouseenter\", function(event) {\r\n                    var $input = $(this), input = this, value = input.inputmask._valueGet();\r\n                    value !== getBuffer().join(\"\") && $input.trigger(\"setvalue\");\r\n                });\r\n            }\r\n            var valueGet, valueSet;\r\n            if (!npt.inputmask.__valueGet) {\r\n                if (opts.noValuePatching !== !0) {\r\n                    if (Object.getOwnPropertyDescriptor) {\r\n                        \"function\" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = \"object\" == typeof \"test\".__proto__ ? function(object) {\r\n                            return object.__proto__;\r\n                        } : function(object) {\r\n                            return object.constructor.prototype;\r\n                        });\r\n                        var valueProperty = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(npt), \"value\") : void 0;\r\n                        valueProperty && valueProperty.get && valueProperty.set ? (valueGet = valueProperty.get, \r\n                        valueSet = valueProperty.set, Object.defineProperty(npt, \"value\", {\r\n                            get: getter,\r\n                            set: setter,\r\n                            configurable: !0\r\n                        })) : \"INPUT\" !== npt.tagName && (valueGet = function() {\r\n                            return this.textContent;\r\n                        }, valueSet = function(value) {\r\n                            this.textContent = value;\r\n                        }, Object.defineProperty(npt, \"value\", {\r\n                            get: getter,\r\n                            set: setter,\r\n                            configurable: !0\r\n                        }));\r\n                    } else document.__lookupGetter__ && npt.__lookupGetter__(\"value\") && (valueGet = npt.__lookupGetter__(\"value\"), \r\n                    valueSet = npt.__lookupSetter__(\"value\"), npt.__defineGetter__(\"value\", getter), \r\n                    npt.__defineSetter__(\"value\", setter));\r\n                    npt.inputmask.__valueGet = valueGet, npt.inputmask.__valueSet = valueSet;\r\n                }\r\n                npt.inputmask._valueGet = function(overruleRTL) {\r\n                    return isRTL && overruleRTL !== !0 ? valueGet.call(this.el).split(\"\").reverse().join(\"\") : valueGet.call(this.el);\r\n                }, npt.inputmask._valueSet = function(value, overruleRTL) {\r\n                    valueSet.call(this.el, null === value || void 0 === value ? \"\" : overruleRTL !== !0 && isRTL ? value.split(\"\").reverse().join(\"\") : value);\r\n                }, void 0 === valueGet && (valueGet = function() {\r\n                    return this.value;\r\n                }, valueSet = function(value) {\r\n                    this.value = value;\r\n                }, patchValhook(npt.type), installNativeValueSetFallback(npt));\r\n            }\r\n        }\r\n        function handleRemove(input, k, pos, strict) {\r\n            function generalize() {\r\n                if (opts.keepStatic) {\r\n                    for (var validInputs = [], lastAlt = getLastValidPosition(-1, !0), positionsClone = $.extend(!0, {}, getMaskSet().validPositions), prevAltPos = getMaskSet().validPositions[lastAlt]; lastAlt >= 0; lastAlt--) {\r\n                        var altPos = getMaskSet().validPositions[lastAlt];\r\n                        if (altPos) {\r\n                            if (altPos.generatedInput !== !0 && /[0-9a-bA-Z]/.test(altPos.input) && validInputs.push(altPos.input), \r\n                            delete getMaskSet().validPositions[lastAlt], void 0 !== altPos.alternation && altPos.locator[altPos.alternation] !== prevAltPos.locator[altPos.alternation]) break;\r\n                            prevAltPos = altPos;\r\n                        }\r\n                    }\r\n                    if (lastAlt > -1) for (getMaskSet().p = seekNext(getLastValidPosition(-1, !0)); validInputs.length > 0; ) {\r\n                        var keypress = new $.Event(\"keypress\");\r\n                        keypress.which = validInputs.pop().charCodeAt(0), keypressEvent.call(input, keypress, !0, !1, !1, getMaskSet().p);\r\n                    } else getMaskSet().validPositions = $.extend(!0, {}, positionsClone);\r\n                }\r\n            }\r\n            if ((opts.numericInput || isRTL) && (k === Inputmask.keyCode.BACKSPACE ? k = Inputmask.keyCode.DELETE : k === Inputmask.keyCode.DELETE && (k = Inputmask.keyCode.BACKSPACE), \r\n            isRTL)) {\r\n                var pend = pos.end;\r\n                pos.end = pos.begin, pos.begin = pend;\r\n            }\r\n            k === Inputmask.keyCode.BACKSPACE && (pos.end - pos.begin < 1 || opts.insertMode === !1) ? (pos.begin = seekPrevious(pos.begin), \r\n            void 0 === getMaskSet().validPositions[pos.begin] || getMaskSet().validPositions[pos.begin].input !== opts.groupSeparator && getMaskSet().validPositions[pos.begin].input !== opts.radixPoint || pos.begin--) : k === Inputmask.keyCode.DELETE && pos.begin === pos.end && (pos.end = isMask(pos.end, !0) ? pos.end + 1 : seekNext(pos.end) + 1, \r\n            void 0 === getMaskSet().validPositions[pos.begin] || getMaskSet().validPositions[pos.begin].input !== opts.groupSeparator && getMaskSet().validPositions[pos.begin].input !== opts.radixPoint || pos.end++), \r\n            stripValidPositions(pos.begin, pos.end, !1, strict), strict !== !0 && generalize();\r\n            var lvp = getLastValidPosition(pos.begin, !0);\r\n            lvp < pos.begin ? getMaskSet().p = seekNext(lvp) : strict !== !0 && (getMaskSet().p = pos.begin);\r\n        }\r\n        function keydownEvent(e) {\r\n            var input = this, $input = $(input), k = e.keyCode, pos = caret(input);\r\n            if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI || e.ctrlKey && k === Inputmask.keyCode.X && !isInputEventSupported(\"cut\")) e.preventDefault(), \r\n            handleRemove(input, k, pos), writeBuffer(input, getBuffer(!0), getMaskSet().p, e, input.inputmask._valueGet() !== getBuffer().join(\"\")), \r\n            input.inputmask._valueGet() === getBufferTemplate().join(\"\") ? $input.trigger(\"cleared\") : isComplete(getBuffer()) === !0 && $input.trigger(\"complete\"), \r\n            opts.showTooltip && (input.title = opts.tooltip || getMaskSet().mask); else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) {\r\n                e.preventDefault();\r\n                var caretPos = seekNext(getLastValidPosition());\r\n                opts.insertMode || caretPos !== getMaskSet().maskLength || e.shiftKey || caretPos--, \r\n                caret(input, e.shiftKey ? pos.begin : caretPos, caretPos, !0);\r\n            } else k === Inputmask.keyCode.HOME && !e.shiftKey || k === Inputmask.keyCode.PAGE_UP ? (e.preventDefault(), \r\n            caret(input, 0, e.shiftKey ? pos.begin : 0, !0)) : (opts.undoOnEscape && k === Inputmask.keyCode.ESCAPE || 90 === k && e.ctrlKey) && e.altKey !== !0 ? (checkVal(input, !0, !1, undoValue.split(\"\")), \r\n            $input.trigger(\"click\")) : k !== Inputmask.keyCode.INSERT || e.shiftKey || e.ctrlKey ? opts.tabThrough === !0 && k === Inputmask.keyCode.TAB ? (e.shiftKey === !0 ? (null === getTest(pos.begin).match.fn && (pos.begin = seekNext(pos.begin)), \r\n            pos.end = seekPrevious(pos.begin, !0), pos.begin = seekPrevious(pos.end, !0)) : (pos.begin = seekNext(pos.begin, !0), \r\n            pos.end = seekNext(pos.begin, !0), pos.end < getMaskSet().maskLength && pos.end--), \r\n            pos.begin < getMaskSet().maskLength && (e.preventDefault(), caret(input, pos.begin, pos.end))) : e.shiftKey || (opts.insertMode === !1 ? k === Inputmask.keyCode.RIGHT ? setTimeout(function() {\r\n                var caretPos = caret(input);\r\n                caret(input, caretPos.begin);\r\n            }, 0) : k === Inputmask.keyCode.LEFT && setTimeout(function() {\r\n                var caretPos = caret(input);\r\n                caret(input, isRTL ? caretPos.begin + 1 : caretPos.begin - 1);\r\n            }, 0) : setTimeout(function() {\r\n                renderColorMask(input);\r\n            }, 0)) : (opts.insertMode = !opts.insertMode, caret(input, opts.insertMode || pos.begin !== getMaskSet().maskLength ? pos.begin : pos.begin - 1));\r\n            opts.onKeyDown.call(this, e, getBuffer(), caret(input).begin, opts), ignorable = $.inArray(k, opts.ignorables) !== -1;\r\n        }\r\n        function keypressEvent(e, checkval, writeOut, strict, ndx) {\r\n            var input = this, $input = $(input), k = e.which || e.charCode || e.keyCode;\r\n            if (!(checkval === !0 || e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable)) return k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join(\"\") && (undoValue = getBuffer().join(\"\"), \r\n            setTimeout(function() {\r\n                $input.trigger(\"change\");\r\n            }, 0)), !0;\r\n            if (k) {\r\n                46 === k && e.shiftKey === !1 && \",\" === opts.radixPoint && (k = 44);\r\n                var forwardPosition, pos = checkval ? {\r\n                    begin: ndx,\r\n                    end: ndx\r\n                } : caret(input), c = String.fromCharCode(k);\r\n                getMaskSet().writeOutBuffer = !0;\r\n                var valResult = isValid(pos, c, strict);\r\n                if (valResult !== !1 && (resetMaskSet(!0), forwardPosition = void 0 !== valResult.caret ? valResult.caret : checkval ? valResult.pos + 1 : seekNext(valResult.pos), \r\n                getMaskSet().p = forwardPosition), writeOut !== !1) {\r\n                    var self = this;\r\n                    if (setTimeout(function() {\r\n                        opts.onKeyValidation.call(self, k, valResult, opts);\r\n                    }, 0), getMaskSet().writeOutBuffer && valResult !== !1) {\r\n                        var buffer = getBuffer();\r\n                        writeBuffer(input, buffer, opts.numericInput && void 0 === valResult.caret ? seekPrevious(forwardPosition) : forwardPosition, e, checkval !== !0), \r\n                        checkval !== !0 && setTimeout(function() {\r\n                            isComplete(buffer) === !0 && $input.trigger(\"complete\");\r\n                        }, 0);\r\n                    }\r\n                }\r\n                if (opts.showTooltip && (input.title = opts.tooltip || getMaskSet().mask), e.preventDefault(), \r\n                checkval) return valResult.forwardPosition = forwardPosition, valResult;\r\n            }\r\n        }\r\n        function pasteEvent(e) {\r\n            var tempValue, input = this, ev = e.originalEvent || e, $input = $(input), inputValue = input.inputmask._valueGet(!0), caretPos = caret(input);\r\n            isRTL && (tempValue = caretPos.end, caretPos.end = caretPos.begin, caretPos.begin = tempValue);\r\n            var valueBeforeCaret = inputValue.substr(0, caretPos.begin), valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);\r\n            if (valueBeforeCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join(\"\") && (valueBeforeCaret = \"\"), \r\n            valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join(\"\") && (valueAfterCaret = \"\"), \r\n            isRTL && (tempValue = valueBeforeCaret, valueBeforeCaret = valueAfterCaret, valueAfterCaret = tempValue), \r\n            window.clipboardData && window.clipboardData.getData) inputValue = valueBeforeCaret + window.clipboardData.getData(\"Text\") + valueAfterCaret; else {\r\n                if (!ev.clipboardData || !ev.clipboardData.getData) return !0;\r\n                inputValue = valueBeforeCaret + ev.clipboardData.getData(\"text/plain\") + valueAfterCaret;\r\n            }\r\n            var pasteValue = inputValue;\r\n            if ($.isFunction(opts.onBeforePaste)) {\r\n                if (pasteValue = opts.onBeforePaste(inputValue, opts), pasteValue === !1) return e.preventDefault();\r\n                pasteValue || (pasteValue = inputValue);\r\n            }\r\n            return checkVal(input, !1, !1, isRTL ? pasteValue.split(\"\").reverse() : pasteValue.toString().split(\"\")), \r\n            writeBuffer(input, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join(\"\")), \r\n            isComplete(getBuffer()) === !0 && $input.trigger(\"complete\"), e.preventDefault();\r\n        }\r\n        function inputFallBackEvent(e) {\r\n            var input = this, inputValue = input.inputmask._valueGet();\r\n            if (getBuffer().join(\"\") !== inputValue) {\r\n                var caretPos = caret(input);\r\n                if (inputValue = inputValue.replace(new RegExp(\"(\" + Inputmask.escapeRegex(getBufferTemplate().join(\"\")) + \")*\"), \"\"), \r\n                iemobile) {\r\n                    var inputChar = inputValue.replace(getBuffer().join(\"\"), \"\");\r\n                    if (1 === inputChar.length) {\r\n                        var keypress = new $.Event(\"keypress\");\r\n                        return keypress.which = inputChar.charCodeAt(0), keypressEvent.call(input, keypress, !0, !0, !1, getMaskSet().validPositions[caretPos.begin - 1] ? caretPos.begin : caretPos.begin - 1), \r\n                        !1;\r\n                    }\r\n                }\r\n                if (caretPos.begin > inputValue.length && (caret(input, inputValue.length), caretPos = caret(input)), \r\n                getBuffer().length - inputValue.length !== 1 || inputValue.charAt(caretPos.begin) === getBuffer()[caretPos.begin] || inputValue.charAt(caretPos.begin + 1) === getBuffer()[caretPos.begin] || isMask(caretPos.begin)) {\r\n                    for (var lvp = getLastValidPosition() + 1, bufferTemplate = getBufferTemplate().join(\"\"); null === inputValue.match(Inputmask.escapeRegex(bufferTemplate) + \"$\"); ) bufferTemplate = bufferTemplate.slice(1);\r\n                    inputValue = inputValue.replace(bufferTemplate, \"\"), inputValue = inputValue.split(\"\"), \r\n                    checkVal(input, !0, !1, inputValue, e, caretPos.begin < lvp), isComplete(getBuffer()) === !0 && $(input).trigger(\"complete\");\r\n                } else e.keyCode = Inputmask.keyCode.BACKSPACE, keydownEvent.call(input, e);\r\n                e.preventDefault();\r\n            }\r\n        }\r\n        function setValueEvent(e) {\r\n            var input = this, value = input.inputmask._valueGet();\r\n            checkVal(input, !0, !1, ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(value, opts) || value : value).split(\"\")), \r\n            undoValue = getBuffer().join(\"\"), (opts.clearMaskOnLostFocus || opts.clearIncomplete) && input.inputmask._valueGet() === getBufferTemplate().join(\"\") && input.inputmask._valueSet(\"\");\r\n        }\r\n        function focusEvent(e) {\r\n            var input = this, nptValue = input.inputmask._valueGet();\r\n            opts.showMaskOnFocus && (!opts.showMaskOnHover || opts.showMaskOnHover && \"\" === nptValue) && (input.inputmask._valueGet() !== getBuffer().join(\"\") ? writeBuffer(input, getBuffer(), seekNext(getLastValidPosition())) : mouseEnter === !1 && caret(input, seekNext(getLastValidPosition()))), \r\n            opts.positionCaretOnTab === !0 && setTimeout(function() {\r\n                clickEvent.apply(this, [ e ]);\r\n            }, 0), undoValue = getBuffer().join(\"\");\r\n        }\r\n        function mouseleaveEvent(e) {\r\n            var input = this;\r\n            if (mouseEnter = !1, opts.clearMaskOnLostFocus && document.activeElement !== input) {\r\n                var buffer = getBuffer().slice(), nptValue = input.inputmask._valueGet();\r\n                nptValue !== input.getAttribute(\"placeholder\") && \"\" !== nptValue && (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join(\"\") ? buffer = [] : clearOptionalTail(buffer), \r\n                writeBuffer(input, buffer));\r\n            }\r\n        }\r\n        function clickEvent(e) {\r\n            function doRadixFocus(clickPos) {\r\n                if (\"\" !== opts.radixPoint) {\r\n                    var vps = getMaskSet().validPositions;\r\n                    if (void 0 === vps[clickPos] || vps[clickPos].input === getPlaceholder(clickPos)) {\r\n                        if (clickPos < seekNext(-1)) return !0;\r\n                        var radixPos = $.inArray(opts.radixPoint, getBuffer());\r\n                        if (radixPos !== -1) {\r\n                            for (var vp in vps) if (radixPos < vp && vps[vp].input !== getPlaceholder(vp)) return !1;\r\n                            return !0;\r\n                        }\r\n                    }\r\n                }\r\n                return !1;\r\n            }\r\n            var input = this;\r\n            setTimeout(function() {\r\n                if (document.activeElement === input) {\r\n                    var selectedCaret = caret(input);\r\n                    if (selectedCaret.begin === selectedCaret.end) switch (opts.positionCaretOnClick) {\r\n                      case \"none\":\r\n                        break;\r\n\r\n                      case \"radixFocus\":\r\n                        if (doRadixFocus(selectedCaret.begin)) {\r\n                            var radixPos = $.inArray(opts.radixPoint, getBuffer().join(\"\"));\r\n                            caret(input, opts.numericInput ? seekNext(radixPos) : radixPos);\r\n                            break;\r\n                        }\r\n\r\n                      default:\r\n                        var clickPosition = selectedCaret.begin, lvclickPosition = getLastValidPosition(clickPosition, !0), lastPosition = seekNext(lvclickPosition);\r\n                        if (clickPosition < lastPosition) caret(input, isMask(clickPosition) || isMask(clickPosition - 1) ? clickPosition : seekNext(clickPosition)); else {\r\n                            var placeholder = getPlaceholder(lastPosition);\r\n                            (\"\" !== placeholder && getBuffer()[lastPosition] !== placeholder && getTest(lastPosition).match.optionalQuantifier !== !0 || !isMask(lastPosition) && getTest(lastPosition).match.def === placeholder) && (lastPosition = seekNext(lastPosition)), \r\n                            caret(input, lastPosition);\r\n                        }\r\n                    }\r\n                }\r\n            }, 0);\r\n        }\r\n        function dblclickEvent(e) {\r\n            var input = this;\r\n            setTimeout(function() {\r\n                caret(input, 0, seekNext(getLastValidPosition()));\r\n            }, 0);\r\n        }\r\n        function cutEvent(e) {\r\n            var input = this, $input = $(input), pos = caret(input), ev = e.originalEvent || e, clipboardData = window.clipboardData || ev.clipboardData, clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);\r\n            clipboardData.setData(\"text\", isRTL ? clipData.reverse().join(\"\") : clipData.join(\"\")), \r\n            document.execCommand && document.execCommand(\"copy\"), handleRemove(input, Inputmask.keyCode.DELETE, pos), \r\n            writeBuffer(input, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join(\"\")), \r\n            input.inputmask._valueGet() === getBufferTemplate().join(\"\") && $input.trigger(\"cleared\"), \r\n            opts.showTooltip && (input.title = opts.tooltip || getMaskSet().mask);\r\n        }\r\n        function blurEvent(e) {\r\n            var $input = $(this), input = this;\r\n            if (input.inputmask) {\r\n                var nptValue = input.inputmask._valueGet(), buffer = getBuffer().slice();\r\n                undoValue !== buffer.join(\"\") && setTimeout(function() {\r\n                    $input.trigger(\"change\"), undoValue = buffer.join(\"\");\r\n                }, 0), \"\" !== nptValue && (opts.clearMaskOnLostFocus && (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join(\"\") ? buffer = [] : clearOptionalTail(buffer)), \r\n                isComplete(buffer) === !1 && (setTimeout(function() {\r\n                    $input.trigger(\"incomplete\");\r\n                }, 0), opts.clearIncomplete && (resetMaskSet(), buffer = opts.clearMaskOnLostFocus ? [] : getBufferTemplate().slice())), \r\n                writeBuffer(input, buffer, void 0, e));\r\n            }\r\n        }\r\n        function mouseenterEvent(e) {\r\n            var input = this;\r\n            mouseEnter = !0, document.activeElement !== input && opts.showMaskOnHover && input.inputmask._valueGet() !== getBuffer().join(\"\") && writeBuffer(input, getBuffer());\r\n        }\r\n        function submitEvent(e) {\r\n            undoValue !== getBuffer().join(\"\") && $el.trigger(\"change\"), opts.clearMaskOnLostFocus && getLastValidPosition() === -1 && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join(\"\") && el.inputmask._valueSet(\"\"), \r\n            opts.removeMaskOnSubmit && (el.inputmask._valueSet(el.inputmask.unmaskedvalue(), !0), \r\n            setTimeout(function() {\r\n                writeBuffer(el, getBuffer());\r\n            }, 0));\r\n        }\r\n        function resetEvent(e) {\r\n            setTimeout(function() {\r\n                $el.trigger(\"setvalue\");\r\n            }, 0);\r\n        }\r\n        function initializeColorMask(input) {\r\n            function findCaretPos(clientx) {\r\n                var caretPos, e = document.createElement(\"span\");\r\n                for (var style in computedStyle) isNaN(style) && style.indexOf(\"font\") !== -1 && (e.style[style] = computedStyle[style]);\r\n                e.style.textTransform = computedStyle.textTransform, e.style.letterSpacing = computedStyle.letterSpacing, \r\n                e.style.position = \"absolute\", e.style.height = \"auto\", e.style.width = \"auto\", \r\n                e.style.visibility = \"hidden\", e.style.whiteSpace = \"nowrap\", document.body.appendChild(e);\r\n                var itl, inputText = input.inputmask._valueGet(), previousWidth = 0;\r\n                for (caretPos = 0, itl = inputText.length; caretPos <= itl; caretPos++) {\r\n                    if (e.innerHTML += inputText.charAt(caretPos) || \"_\", e.offsetWidth >= clientx) {\r\n                        var offset1 = clientx - previousWidth, offset2 = e.offsetWidth - clientx;\r\n                        e.innerHTML = inputText.charAt(caretPos), offset1 -= e.offsetWidth / 3, caretPos = offset1 < offset2 ? caretPos - 1 : caretPos;\r\n                        break;\r\n                    }\r\n                    previousWidth = e.offsetWidth;\r\n                }\r\n                return document.body.removeChild(e), caretPos;\r\n            }\r\n            function position() {\r\n                colorMask.style.position = \"absolute\", colorMask.style.top = offset.top + \"px\", \r\n                colorMask.style.left = offset.left + \"px\", colorMask.style.width = parseInt(input.offsetWidth) - parseInt(computedStyle.paddingLeft) - parseInt(computedStyle.paddingRight) - parseInt(computedStyle.borderLeftWidth) - parseInt(computedStyle.borderRightWidth) + \"px\", \r\n                colorMask.style.height = parseInt(input.offsetHeight) - parseInt(computedStyle.paddingTop) - parseInt(computedStyle.paddingBottom) - parseInt(computedStyle.borderTopWidth) - parseInt(computedStyle.borderBottomWidth) + \"px\", \r\n                colorMask.style.lineHeight = colorMask.style.height, colorMask.style.zIndex = isNaN(computedStyle.zIndex) ? -1 : computedStyle.zIndex - 1, \r\n                colorMask.style.webkitAppearance = \"textfield\", colorMask.style.mozAppearance = \"textfield\", \r\n                colorMask.style.Appearance = \"textfield\";\r\n            }\r\n            var offset = $(input).position(), computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null);\r\n            input.parentNode;\r\n            colorMask = document.createElement(\"div\"), document.body.appendChild(colorMask);\r\n            for (var style in computedStyle) isNaN(style) && \"cssText\" !== style && style.indexOf(\"webkit\") == -1 && (colorMask.style[style] = computedStyle[style]);\r\n            input.style.backgroundColor = \"transparent\", input.style.color = \"transparent\", \r\n            input.style.webkitAppearance = \"caret\", input.style.mozAppearance = \"caret\", input.style.Appearance = \"caret\", \r\n            position(), $(window).on(\"resize\", function(e) {\r\n                offset = $(input).position(), computedStyle = (input.ownerDocument.defaultView || window).getComputedStyle(input, null), \r\n                position();\r\n            }), $(input).on(\"click\", function(e) {\r\n                return caret(input, findCaretPos(e.clientX)), clickEvent.call(this, [ e ]);\r\n            });\r\n        }\r\n        function renderColorMask(input, buffer, caretPos) {\r\n            function handleStatic() {\r\n                static || null !== test.fn && void 0 !== testPos.input ? static && null !== test.fn && void 0 !== testPos.input && (static = !1, \r\n                maskTemplate += \"</span>\") : (static = !0, maskTemplate += \"<span class='im-static''>\");\r\n            }\r\n            if (void 0 !== colorMask) {\r\n                buffer = buffer || getBuffer(), void 0 === caretPos ? caretPos = caret(input) : void 0 === caretPos.begin && (caretPos = {\r\n                    begin: caretPos,\r\n                    end: caretPos\r\n                });\r\n                var maskTemplate = \"\", static = !1;\r\n                if (\"\" != buffer) {\r\n                    var ndxIntlzr, test, testPos, pos = 0, lvp = getLastValidPosition();\r\n                    do pos === caretPos.begin && document.activeElement === input && (maskTemplate += \"<span class='im-caret' style='border-right-width: 1px;border-right-style: solid;'></span>\"), \r\n                    getMaskSet().validPositions[pos] ? (testPos = getMaskSet().validPositions[pos], \r\n                    test = testPos.match, ndxIntlzr = testPos.locator.slice(), handleStatic(), maskTemplate += testPos.input) : (testPos = getTestTemplate(pos, ndxIntlzr, pos - 1), \r\n                    test = testPos.match, ndxIntlzr = testPos.locator.slice(), (opts.jitMasking === !1 || pos < lvp || Number.isFinite(opts.jitMasking) && opts.jitMasking > pos) && (handleStatic(), \r\n                    maskTemplate += getPlaceholder(pos, test))), pos++; while ((void 0 === maxLength || pos < maxLength) && (null !== test.fn || \"\" !== test.def) || lvp > pos);\r\n                }\r\n                colorMask.innerHTML = maskTemplate;\r\n            }\r\n        }\r\n        function mask(elem) {\r\n            if (isElementTypeSupported(elem, opts) && (el = elem, $el = $(el), opts.showTooltip && (el.title = opts.tooltip || getMaskSet().mask), \r\n            (\"rtl\" === el.dir || opts.rightAlign) && (el.style.textAlign = \"right\"), (\"rtl\" === el.dir || opts.numericInput) && (el.dir = \"ltr\", \r\n            el.removeAttribute(\"dir\"), el.inputmask.isRTL = !0, isRTL = !0), opts.colorMask === !0 && initializeColorMask(el), \r\n            android && (el.hasOwnProperty(\"inputmode\") && (el.inputmode = opts.inputmode, el.setAttribute(\"inputmode\", opts.inputmode)), \r\n            \"rtfm\" === opts.androidHack && (opts.colorMask !== !0 && initializeColorMask(el), \r\n            el.type = \"password\")), EventRuler.off(el), patchValueProperty(el), EventRuler.on(el, \"submit\", submitEvent), \r\n            EventRuler.on(el, \"reset\", resetEvent), EventRuler.on(el, \"mouseenter\", mouseenterEvent), \r\n            EventRuler.on(el, \"blur\", blurEvent), EventRuler.on(el, \"focus\", focusEvent), EventRuler.on(el, \"mouseleave\", mouseleaveEvent), \r\n            opts.colorMask !== !0 && EventRuler.on(el, \"click\", clickEvent), EventRuler.on(el, \"dblclick\", dblclickEvent), \r\n            EventRuler.on(el, \"paste\", pasteEvent), EventRuler.on(el, \"dragdrop\", pasteEvent), \r\n            EventRuler.on(el, \"drop\", pasteEvent), EventRuler.on(el, \"cut\", cutEvent), EventRuler.on(el, \"complete\", opts.oncomplete), \r\n            EventRuler.on(el, \"incomplete\", opts.onincomplete), EventRuler.on(el, \"cleared\", opts.oncleared), \r\n            opts.inputEventOnly !== !0 && (EventRuler.on(el, \"keydown\", keydownEvent), EventRuler.on(el, \"keypress\", keypressEvent)), \r\n            EventRuler.on(el, \"compositionstart\", $.noop), EventRuler.on(el, \"compositionupdate\", $.noop), \r\n            EventRuler.on(el, \"compositionend\", $.noop), EventRuler.on(el, \"keyup\", $.noop), \r\n            EventRuler.on(el, \"input\", inputFallBackEvent), EventRuler.on(el, \"setvalue\", setValueEvent), \r\n            getBufferTemplate(), \"\" !== el.inputmask._valueGet() || opts.clearMaskOnLostFocus === !1 || document.activeElement === el)) {\r\n                var initialValue = $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(el.inputmask._valueGet(), opts) || el.inputmask._valueGet() : el.inputmask._valueGet();\r\n                checkVal(el, !0, !1, initialValue.split(\"\"));\r\n                var buffer = getBuffer().slice();\r\n                undoValue = buffer.join(\"\"), isComplete(buffer) === !1 && opts.clearIncomplete && resetMaskSet(), \r\n                opts.clearMaskOnLostFocus && document.activeElement !== el && (getLastValidPosition() === -1 ? buffer = [] : clearOptionalTail(buffer)), \r\n                writeBuffer(el, buffer), document.activeElement === el && caret(el, seekNext(getLastValidPosition()));\r\n            }\r\n        }\r\n        var undoValue, el, $el, maxLength, colorMask, valueBuffer, isRTL = !1, skipKeyPressEvent = !1, skipInputEvent = !1, ignorable = !1, mouseEnter = !1, EventRuler = {\r\n            on: function(input, eventName, eventHandler) {\r\n                var ev = function(e) {\r\n                    if (void 0 === this.inputmask && \"FORM\" !== this.nodeName) {\r\n                        var imOpts = $.data(this, \"_inputmask_opts\");\r\n                        imOpts ? new Inputmask(imOpts).mask(this) : EventRuler.off(this);\r\n                    } else {\r\n                        if (\"setvalue\" === e.type || !(this.disabled || this.readOnly && !(\"keydown\" === e.type && e.ctrlKey && 67 === e.keyCode || opts.tabThrough === !1 && e.keyCode === Inputmask.keyCode.TAB))) {\r\n                            switch (e.type) {\r\n                              case \"input\":\r\n                                if (skipInputEvent === !0) return skipInputEvent = !1, e.preventDefault();\r\n                                break;\r\n\r\n                              case \"keydown\":\r\n                                skipKeyPressEvent = !1, skipInputEvent = !1;\r\n                                break;\r\n\r\n                              case \"keypress\":\r\n                                if (skipKeyPressEvent === !0) return e.preventDefault();\r\n                                skipKeyPressEvent = !0;\r\n                                break;\r\n\r\n                              case \"click\":\r\n                                if (iemobile || iphone) {\r\n                                    var that = this, args = arguments;\r\n                                    return setTimeout(function() {\r\n                                        eventHandler.apply(that, args);\r\n                                    }, 0), !1;\r\n                                }\r\n                            }\r\n                            var returnVal = eventHandler.apply(this, arguments);\r\n                            return returnVal === !1 && (e.preventDefault(), e.stopPropagation()), returnVal;\r\n                        }\r\n                        e.preventDefault();\r\n                    }\r\n                };\r\n                input.inputmask.events[eventName] = input.inputmask.events[eventName] || [], input.inputmask.events[eventName].push(ev), \r\n                $.inArray(eventName, [ \"submit\", \"reset\" ]) !== -1 ? null != input.form && $(input.form).on(eventName, ev) : $(input).on(eventName, ev);\r\n            },\r\n            off: function(input, event) {\r\n                if (input.inputmask && input.inputmask.events) {\r\n                    var events;\r\n                    event ? (events = [], events[event] = input.inputmask.events[event]) : events = input.inputmask.events, \r\n                    $.each(events, function(eventName, evArr) {\r\n                        for (;evArr.length > 0; ) {\r\n                            var ev = evArr.pop();\r\n                            $.inArray(eventName, [ \"submit\", \"reset\" ]) !== -1 ? null != input.form && $(input.form).off(eventName, ev) : $(input).off(eventName, ev);\r\n                        }\r\n                        delete input.inputmask.events[eventName];\r\n                    });\r\n                }\r\n            }\r\n        };\r\n        if (void 0 !== actionObj) switch (actionObj.action) {\r\n          case \"isComplete\":\r\n            return el = actionObj.el, isComplete(getBuffer());\r\n\r\n          case \"unmaskedvalue\":\r\n            return el = actionObj.el, void 0 !== el && void 0 !== el.inputmask ? (maskset = el.inputmask.maskset, \r\n            opts = el.inputmask.opts, isRTL = el.inputmask.isRTL) : (valueBuffer = actionObj.value, \r\n            opts.numericInput && (isRTL = !0), valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(valueBuffer, opts) || valueBuffer : valueBuffer).split(\"\"), \r\n            checkVal(void 0, !1, !1, isRTL ? valueBuffer.reverse() : valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite(void 0, getBuffer(), 0, opts)), \r\n            unmaskedvalue(el);\r\n\r\n          case \"mask\":\r\n            el = actionObj.el, maskset = el.inputmask.maskset, opts = el.inputmask.opts, isRTL = el.inputmask.isRTL, \r\n            mask(el);\r\n            break;\r\n\r\n          case \"format\":\r\n            return opts.numericInput && (isRTL = !0), valueBuffer = ($.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(actionObj.value, opts) || actionObj.value : actionObj.value).split(\"\"), \r\n            checkVal(void 0, !1, !1, isRTL ? valueBuffer.reverse() : valueBuffer), $.isFunction(opts.onBeforeWrite) && opts.onBeforeWrite(void 0, getBuffer(), 0, opts), \r\n            actionObj.metadata ? {\r\n                value: isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\"),\r\n                metadata: maskScope({\r\n                    action: \"getmetadata\"\r\n                }, maskset, opts)\r\n            } : isRTL ? getBuffer().slice().reverse().join(\"\") : getBuffer().join(\"\");\r\n\r\n          case \"isValid\":\r\n            opts.numericInput && (isRTL = !0), actionObj.value ? (valueBuffer = actionObj.value.split(\"\"), \r\n            checkVal(void 0, !1, !0, isRTL ? valueBuffer.reverse() : valueBuffer)) : actionObj.value = getBuffer().join(\"\");\r\n            for (var buffer = getBuffer(), rl = determineLastRequiredPosition(), lmib = buffer.length - 1; lmib > rl && !isMask(lmib); lmib--) ;\r\n            return buffer.splice(rl, lmib + 1 - rl), isComplete(buffer) && actionObj.value === getBuffer().join(\"\");\r\n\r\n          case \"getemptymask\":\r\n            return getBufferTemplate().join(\"\");\r\n\r\n          case \"remove\":\r\n            el = actionObj.el, $el = $(el), maskset = el.inputmask.maskset, opts = el.inputmask.opts, \r\n            el.inputmask._valueSet(unmaskedvalue(el)), EventRuler.off(el);\r\n            var valueProperty;\r\n            Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? (valueProperty = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), \"value\"), \r\n            valueProperty && el.inputmask.__valueGet && Object.defineProperty(el, \"value\", {\r\n                get: el.inputmask.__valueGet,\r\n                set: el.inputmask.__valueSet,\r\n                configurable: !0\r\n            })) : document.__lookupGetter__ && el.__lookupGetter__(\"value\") && el.inputmask.__valueGet && (el.__defineGetter__(\"value\", el.inputmask.__valueGet), \r\n            el.__defineSetter__(\"value\", el.inputmask.__valueSet)), el.inputmask = void 0;\r\n            break;\r\n\r\n          case \"getmetadata\":\r\n            if ($.isArray(maskset.metadata)) {\r\n                for (var alternation, lvp = getLastValidPosition(void 0, !0), firstAlt = lvp; firstAlt >= 0; firstAlt--) if (getMaskSet().validPositions[firstAlt] && void 0 !== getMaskSet().validPositions[firstAlt].alternation) {\r\n                    alternation = getMaskSet().validPositions[firstAlt].alternation;\r\n                    break;\r\n                }\r\n                return void 0 !== alternation ? maskset.metadata[getMaskSet().validPositions[firstAlt].locator[alternation]] : [];\r\n            }\r\n            return maskset.metadata;\r\n        }\r\n    }\r\n    Inputmask.prototype = {\r\n        defaults: {\r\n            placeholder: \"_\",\r\n            optionalmarker: {\r\n                start: \"[\",\r\n                end: \"]\"\r\n            },\r\n            quantifiermarker: {\r\n                start: \"{\",\r\n                end: \"}\"\r\n            },\r\n            groupmarker: {\r\n                start: \"(\",\r\n                end: \")\"\r\n            },\r\n            alternatormarker: \"|\",\r\n            escapeChar: \"\\\\\",\r\n            mask: null,\r\n            oncomplete: $.noop,\r\n            onincomplete: $.noop,\r\n            oncleared: $.noop,\r\n            repeat: 0,\r\n            greedy: !0,\r\n            autoUnmask: !1,\r\n            removeMaskOnSubmit: !1,\r\n            clearMaskOnLostFocus: !0,\r\n            insertMode: !0,\r\n            clearIncomplete: !1,\r\n            aliases: {},\r\n            alias: null,\r\n            onKeyDown: $.noop,\r\n            onBeforeMask: null,\r\n            onBeforePaste: function(pastedValue, opts) {\r\n                return $.isFunction(opts.onBeforeMask) ? opts.onBeforeMask(pastedValue, opts) : pastedValue;\r\n            },\r\n            onBeforeWrite: null,\r\n            onUnMask: null,\r\n            showMaskOnFocus: !0,\r\n            showMaskOnHover: !0,\r\n            onKeyValidation: $.noop,\r\n            skipOptionalPartCharacter: \" \",\r\n            showTooltip: !1,\r\n            tooltip: void 0,\r\n            numericInput: !1,\r\n            rightAlign: !1,\r\n            undoOnEscape: !0,\r\n            radixPoint: \"\",\r\n            radixPointDefinitionSymbol: void 0,\r\n            groupSeparator: \"\",\r\n            keepStatic: null,\r\n            positionCaretOnTab: !0,\r\n            tabThrough: !1,\r\n            supportsInputType: [ \"text\", \"tel\", \"password\" ],\r\n            definitions: {\r\n                \"9\": {\r\n                    validator: \"[0-9]\",\r\n                    cardinality: 1,\r\n                    definitionSymbol: \"*\"\r\n                },\r\n                a: {\r\n                    validator: \"[A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\r\n                    cardinality: 1,\r\n                    definitionSymbol: \"*\"\r\n                },\r\n                \"*\": {\r\n                    validator: \"[0-9A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\r\n                    cardinality: 1\r\n                }\r\n            },\r\n            ignorables: [ 8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123 ],\r\n            isComplete: null,\r\n            canClearPosition: $.noop,\r\n            postValidation: null,\r\n            staticDefinitionSymbol: void 0,\r\n            jitMasking: !1,\r\n            nullable: !0,\r\n            inputEventOnly: !1,\r\n            noValuePatching: !1,\r\n            positionCaretOnClick: \"lvp\",\r\n            casing: null,\r\n            inputmode: \"verbatim\",\r\n            colorMask: !1,\r\n            androidHack: !1\r\n        },\r\n        masksCache: {},\r\n        mask: function(elems) {\r\n            var that = this;\r\n            return \"string\" == typeof elems && (elems = document.getElementById(elems) || document.querySelectorAll(elems)), \r\n            elems = elems.nodeName ? [ elems ] : elems, $.each(elems, function(ndx, el) {\r\n                var scopedOpts = $.extend(!0, {}, that.opts);\r\n                importAttributeOptions(el, scopedOpts, $.extend(!0, {}, that.userOptions), that.dataAttribute);\r\n                var maskset = generateMaskSet(scopedOpts, that.noMasksCache);\r\n                void 0 !== maskset && (void 0 !== el.inputmask && el.inputmask.remove(), el.inputmask = new Inputmask(), \r\n                el.inputmask.opts = scopedOpts, el.inputmask.noMasksCache = that.noMasksCache, el.inputmask.userOptions = $.extend(!0, {}, that.userOptions), \r\n                el.inputmask.el = el, el.inputmask.maskset = maskset, el.inputmask.isRTL = !1, $.data(el, \"_inputmask_opts\", scopedOpts), \r\n                maskScope({\r\n                    action: \"mask\",\r\n                    el: el\r\n                }));\r\n            }), elems && elems[0] ? elems[0].inputmask || this : this;\r\n        },\r\n        option: function(options, noremask) {\r\n            return \"string\" == typeof options ? this.opts[options] : \"object\" == typeof options ? ($.extend(this.userOptions, options), \r\n            this.el && noremask !== !0 && this.mask(this.el), this) : void 0;\r\n        },\r\n        unmaskedvalue: function(value) {\r\n            return maskScope({\r\n                action: \"unmaskedvalue\",\r\n                el: this.el,\r\n                value: value\r\n            }, this.el && this.el.inputmask ? this.el.inputmask.maskset : generateMaskSet(this.opts, this.noMasksCache), this.opts);\r\n        },\r\n        remove: function() {\r\n            if (this.el) return maskScope({\r\n                action: \"remove\",\r\n                el: this.el\r\n            }), this.el.inputmask = void 0, this.el;\r\n        },\r\n        getemptymask: function() {\r\n            return maskScope({\r\n                action: \"getemptymask\"\r\n            }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);\r\n        },\r\n        hasMaskedValue: function() {\r\n            return !this.opts.autoUnmask;\r\n        },\r\n        isComplete: function() {\r\n            return maskScope({\r\n                action: \"isComplete\",\r\n                el: this.el\r\n            }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);\r\n        },\r\n        getmetadata: function() {\r\n            return maskScope({\r\n                action: \"getmetadata\"\r\n            }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);\r\n        },\r\n        isValid: function(value) {\r\n            return maskScope({\r\n                action: \"isValid\",\r\n                value: value\r\n            }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);\r\n        },\r\n        format: function(value, metadata) {\r\n            return maskScope({\r\n                action: \"format\",\r\n                value: value,\r\n                metadata: metadata\r\n            }, this.maskset || generateMaskSet(this.opts, this.noMasksCache), this.opts);\r\n        }\r\n    }, Inputmask.extendDefaults = function(options) {\r\n        $.extend(!0, Inputmask.prototype.defaults, options);\r\n    }, Inputmask.extendDefinitions = function(definition) {\r\n        $.extend(!0, Inputmask.prototype.defaults.definitions, definition);\r\n    }, Inputmask.extendAliases = function(alias) {\r\n        $.extend(!0, Inputmask.prototype.defaults.aliases, alias);\r\n    }, Inputmask.format = function(value, options, metadata) {\r\n        return Inputmask(options).format(value, metadata);\r\n    }, Inputmask.unmask = function(value, options) {\r\n        return Inputmask(options).unmaskedvalue(value);\r\n    }, Inputmask.isValid = function(value, options) {\r\n        return Inputmask(options).isValid(value);\r\n    }, Inputmask.remove = function(elems) {\r\n        $.each(elems, function(ndx, el) {\r\n            el.inputmask && el.inputmask.remove();\r\n        });\r\n    }, Inputmask.escapeRegex = function(str) {\r\n        var specials = [ \"/\", \".\", \"*\", \"+\", \"?\", \"|\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"\\\\\", \"$\", \"^\" ];\r\n        return str.replace(new RegExp(\"(\\\\\" + specials.join(\"|\\\\\") + \")\", \"gim\"), \"\\\\$1\");\r\n    }, Inputmask.keyCode = {\r\n        ALT: 18,\r\n        BACKSPACE: 8,\r\n        BACKSPACE_SAFARI: 127,\r\n        CAPS_LOCK: 20,\r\n        COMMA: 188,\r\n        COMMAND: 91,\r\n        COMMAND_LEFT: 91,\r\n        COMMAND_RIGHT: 93,\r\n        CONTROL: 17,\r\n        DELETE: 46,\r\n        DOWN: 40,\r\n        END: 35,\r\n        ENTER: 13,\r\n        ESCAPE: 27,\r\n        HOME: 36,\r\n        INSERT: 45,\r\n        LEFT: 37,\r\n        MENU: 93,\r\n        NUMPAD_ADD: 107,\r\n        NUMPAD_DECIMAL: 110,\r\n        NUMPAD_DIVIDE: 111,\r\n        NUMPAD_ENTER: 108,\r\n        NUMPAD_MULTIPLY: 106,\r\n        NUMPAD_SUBTRACT: 109,\r\n        PAGE_DOWN: 34,\r\n        PAGE_UP: 33,\r\n        PERIOD: 190,\r\n        RIGHT: 39,\r\n        SHIFT: 16,\r\n        SPACE: 32,\r\n        TAB: 9,\r\n        UP: 38,\r\n        WINDOWS: 91,\r\n        X: 88\r\n    }, Inputmask.analyseMask = function(mask, opts) {\r\n        function MaskToken(isGroup, isOptional, isQuantifier, isAlternator) {\r\n            this.matches = [], this.isGroup = isGroup || !1, this.isOptional = isOptional || !1, \r\n            this.isQuantifier = isQuantifier || !1, this.isAlternator = isAlternator || !1, \r\n            this.quantifier = {\r\n                min: 1,\r\n                max: 1\r\n            };\r\n        }\r\n        function insertTestDefinition(mtoken, element, position) {\r\n            var maskdef = opts.definitions[element];\r\n            position = void 0 !== position ? position : mtoken.matches.length;\r\n            var prevMatch = mtoken.matches[position - 1];\r\n            if (maskdef && !escaped) {\r\n                maskdef.placeholder = $.isFunction(maskdef.placeholder) ? maskdef.placeholder(opts) : maskdef.placeholder;\r\n                for (var prevalidators = maskdef.prevalidator, prevalidatorsL = prevalidators ? prevalidators.length : 0, i = 1; i < maskdef.cardinality; i++) {\r\n                    var prevalidator = prevalidatorsL >= i ? prevalidators[i - 1] : [], validator = prevalidator.validator, cardinality = prevalidator.cardinality;\r\n                    mtoken.matches.splice(position++, 0, {\r\n                        fn: validator ? \"string\" == typeof validator ? new RegExp(validator) : new function() {\r\n                            this.test = validator;\r\n                        }() : new RegExp(\".\"),\r\n                        cardinality: cardinality ? cardinality : 1,\r\n                        optionality: mtoken.isOptional,\r\n                        newBlockMarker: void 0 === prevMatch || prevMatch.def !== (maskdef.definitionSymbol || element),\r\n                        casing: maskdef.casing,\r\n                        def: maskdef.definitionSymbol || element,\r\n                        placeholder: maskdef.placeholder,\r\n                        nativeDef: element\r\n                    }), prevMatch = mtoken.matches[position - 1];\r\n                }\r\n                mtoken.matches.splice(position++, 0, {\r\n                    fn: maskdef.validator ? \"string\" == typeof maskdef.validator ? new RegExp(maskdef.validator) : new function() {\r\n                        this.test = maskdef.validator;\r\n                    }() : new RegExp(\".\"),\r\n                    cardinality: maskdef.cardinality,\r\n                    optionality: mtoken.isOptional,\r\n                    newBlockMarker: void 0 === prevMatch || prevMatch.def !== (maskdef.definitionSymbol || element),\r\n                    casing: maskdef.casing,\r\n                    def: maskdef.definitionSymbol || element,\r\n                    placeholder: maskdef.placeholder,\r\n                    nativeDef: element\r\n                });\r\n            } else mtoken.matches.splice(position++, 0, {\r\n                fn: null,\r\n                cardinality: 0,\r\n                optionality: mtoken.isOptional,\r\n                newBlockMarker: void 0 === prevMatch || prevMatch.def !== element,\r\n                casing: null,\r\n                def: opts.staticDefinitionSymbol || element,\r\n                placeholder: void 0 !== opts.staticDefinitionSymbol ? element : void 0,\r\n                nativeDef: element\r\n            }), escaped = !1;\r\n        }\r\n        function verifyGroupMarker(lastMatch, isOpenGroup) {\r\n            lastMatch.isGroup && (lastMatch.isGroup = !1, insertTestDefinition(lastMatch, opts.groupmarker.start, 0), \r\n            isOpenGroup !== !0 && insertTestDefinition(lastMatch, opts.groupmarker.end));\r\n        }\r\n        function maskCurrentToken(m, currentToken, lastMatch, extraCondition) {\r\n            currentToken.matches.length > 0 && (void 0 === extraCondition || extraCondition) && (lastMatch = currentToken.matches[currentToken.matches.length - 1], \r\n            verifyGroupMarker(lastMatch)), insertTestDefinition(currentToken, m);\r\n        }\r\n        function defaultCase() {\r\n            if (openenings.length > 0) {\r\n                if (currentOpeningToken = openenings[openenings.length - 1], maskCurrentToken(m, currentOpeningToken, lastMatch, !currentOpeningToken.isAlternator), \r\n                currentOpeningToken.isAlternator) {\r\n                    alternator = openenings.pop();\r\n                    for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1;\r\n                    openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1], \r\n                    currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator);\r\n                }\r\n            } else maskCurrentToken(m, currentToken, lastMatch);\r\n        }\r\n        function reverseTokens(maskToken) {\r\n            function reverseStatic(st) {\r\n                return st === opts.optionalmarker.start ? st = opts.optionalmarker.end : st === opts.optionalmarker.end ? st = opts.optionalmarker.start : st === opts.groupmarker.start ? st = opts.groupmarker.end : st === opts.groupmarker.end && (st = opts.groupmarker.start), \r\n                st;\r\n            }\r\n            maskToken.matches = maskToken.matches.reverse();\r\n            for (var match in maskToken.matches) {\r\n                var intMatch = parseInt(match);\r\n                if (maskToken.matches[match].isQuantifier && maskToken.matches[intMatch + 1] && maskToken.matches[intMatch + 1].isGroup) {\r\n                    var qt = maskToken.matches[match];\r\n                    maskToken.matches.splice(match, 1), maskToken.matches.splice(intMatch + 1, 0, qt);\r\n                }\r\n                void 0 !== maskToken.matches[match].matches ? maskToken.matches[match] = reverseTokens(maskToken.matches[match]) : maskToken.matches[match] = reverseStatic(maskToken.matches[match]);\r\n            }\r\n            return maskToken;\r\n        }\r\n        for (var match, m, openingToken, currentOpeningToken, alternator, lastMatch, groupToken, tokenizer = /(?:[?*+]|\\{[0-9\\+\\*]+(?:,[0-9\\+\\*]*)?\\})|[^.?*+^${[]()|\\\\]+|./g, escaped = !1, currentToken = new MaskToken(), openenings = [], maskTokens = []; match = tokenizer.exec(mask); ) if (m = match[0], \r\n        escaped) defaultCase(); else switch (m.charAt(0)) {\r\n          case opts.escapeChar:\r\n            escaped = !0;\r\n            break;\r\n\r\n          case opts.optionalmarker.end:\r\n          case opts.groupmarker.end:\r\n            if (openingToken = openenings.pop(), void 0 !== openingToken) if (openenings.length > 0) {\r\n                if (currentOpeningToken = openenings[openenings.length - 1], currentOpeningToken.matches.push(openingToken), \r\n                currentOpeningToken.isAlternator) {\r\n                    alternator = openenings.pop();\r\n                    for (var mndx = 0; mndx < alternator.matches.length; mndx++) alternator.matches[mndx].isGroup = !1;\r\n                    openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1], \r\n                    currentOpeningToken.matches.push(alternator)) : currentToken.matches.push(alternator);\r\n                }\r\n            } else currentToken.matches.push(openingToken); else defaultCase();\r\n            break;\r\n\r\n          case opts.optionalmarker.start:\r\n            openenings.push(new MaskToken((!1), (!0)));\r\n            break;\r\n\r\n          case opts.groupmarker.start:\r\n            openenings.push(new MaskToken((!0)));\r\n            break;\r\n\r\n          case opts.quantifiermarker.start:\r\n            var quantifier = new MaskToken((!1), (!1), (!0));\r\n            m = m.replace(/[{}]/g, \"\");\r\n            var mq = m.split(\",\"), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]), mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);\r\n            if (\"*\" !== mq1 && \"+\" !== mq1 || (mq0 = \"*\" === mq1 ? 0 : 1), quantifier.quantifier = {\r\n                min: mq0,\r\n                max: mq1\r\n            }, openenings.length > 0) {\r\n                var matches = openenings[openenings.length - 1].matches;\r\n                match = matches.pop(), match.isGroup || (groupToken = new MaskToken((!0)), groupToken.matches.push(match), \r\n                match = groupToken), matches.push(match), matches.push(quantifier);\r\n            } else match = currentToken.matches.pop(), match.isGroup || (groupToken = new MaskToken((!0)), \r\n            groupToken.matches.push(match), match = groupToken), currentToken.matches.push(match), \r\n            currentToken.matches.push(quantifier);\r\n            break;\r\n\r\n          case opts.alternatormarker:\r\n            openenings.length > 0 ? (currentOpeningToken = openenings[openenings.length - 1], \r\n            lastMatch = currentOpeningToken.matches.pop()) : lastMatch = currentToken.matches.pop(), \r\n            lastMatch.isAlternator ? openenings.push(lastMatch) : (alternator = new MaskToken((!1), (!1), (!1), (!0)), \r\n            alternator.matches.push(lastMatch), openenings.push(alternator));\r\n            break;\r\n\r\n          default:\r\n            defaultCase();\r\n        }\r\n        for (;openenings.length > 0; ) openingToken = openenings.pop(), verifyGroupMarker(openingToken, !0), \r\n        currentToken.matches.push(openingToken);\r\n        return currentToken.matches.length > 0 && (lastMatch = currentToken.matches[currentToken.matches.length - 1], \r\n        verifyGroupMarker(lastMatch), maskTokens.push(currentToken)), opts.numericInput && reverseTokens(maskTokens[0]), \r\n        maskTokens;\r\n    };\r\n    var ua = navigator.userAgent, mobile = /mobile/i.test(ua), iemobile = /iemobile/i.test(ua), iphone = /iphone/i.test(ua) && !iemobile, android = /android/i.test(ua) && !iemobile;\r\n    return window.Inputmask = Inputmask, Inputmask;\r\n}(jQuery), function($, Inputmask) {\r\n    return void 0 === $.fn.inputmask && ($.fn.inputmask = function(fn, options) {\r\n        var nptmask, input = this[0];\r\n        if (void 0 === options && (options = {}), \"string\" == typeof fn) switch (fn) {\r\n          case \"unmaskedvalue\":\r\n            return input && input.inputmask ? input.inputmask.unmaskedvalue() : $(input).val();\r\n\r\n          case \"remove\":\r\n            return this.each(function() {\r\n                this.inputmask && this.inputmask.remove();\r\n            });\r\n\r\n          case \"getemptymask\":\r\n            return input && input.inputmask ? input.inputmask.getemptymask() : \"\";\r\n\r\n          case \"hasMaskedValue\":\r\n            return !(!input || !input.inputmask) && input.inputmask.hasMaskedValue();\r\n\r\n          case \"isComplete\":\r\n            return !input || !input.inputmask || input.inputmask.isComplete();\r\n\r\n          case \"getmetadata\":\r\n            return input && input.inputmask ? input.inputmask.getmetadata() : void 0;\r\n\r\n          case \"setvalue\":\r\n            $(input).val(options), input && void 0 === input.inputmask && $(input).triggerHandler(\"setvalue\");\r\n            break;\r\n\r\n          case \"option\":\r\n            if (\"string\" != typeof options) return this.each(function() {\r\n                if (void 0 !== this.inputmask) return this.inputmask.option(options);\r\n            });\r\n            if (input && void 0 !== input.inputmask) return input.inputmask.option(options);\r\n            break;\r\n\r\n          default:\r\n            return options.alias = fn, nptmask = new Inputmask(options), this.each(function() {\r\n                nptmask.mask(this);\r\n            });\r\n        } else {\r\n            if (\"object\" == typeof fn) return nptmask = new Inputmask(fn), void 0 === fn.mask && void 0 === fn.alias ? this.each(function() {\r\n                return void 0 !== this.inputmask ? this.inputmask.option(fn) : void nptmask.mask(this);\r\n            }) : this.each(function() {\r\n                nptmask.mask(this);\r\n            });\r\n            if (void 0 === fn) return this.each(function() {\r\n                nptmask = new Inputmask(options), nptmask.mask(this);\r\n            });\r\n        }\r\n    }), $.fn.inputmask;\r\n}(jQuery, Inputmask), function($, Inputmask) {\r\n    function isLeapYear(year) {\r\n        return isNaN(year) || 29 === new Date(year, 2, 0).getDate();\r\n    }\r\n    return Inputmask.extendDefinitions({\r\n        h: {\r\n            validator: \"[01][0-9]|2[0-3]\",\r\n            cardinality: 2,\r\n            prevalidator: [ {\r\n                validator: \"[0-2]\",\r\n                cardinality: 1\r\n            } ]\r\n        },\r\n        s: {\r\n            validator: \"[0-5][0-9]\",\r\n            cardinality: 2,\r\n            prevalidator: [ {\r\n                validator: \"[0-5]\",\r\n                cardinality: 1\r\n            } ]\r\n        },\r\n        d: {\r\n            validator: \"0[1-9]|[12][0-9]|3[01]\",\r\n            cardinality: 2,\r\n            prevalidator: [ {\r\n                validator: \"[0-3]\",\r\n                cardinality: 1\r\n            } ]\r\n        },\r\n        m: {\r\n            validator: \"0[1-9]|1[012]\",\r\n            cardinality: 2,\r\n            prevalidator: [ {\r\n                validator: \"[01]\",\r\n                cardinality: 1\r\n            } ]\r\n        },\r\n        y: {\r\n            validator: \"(19|20)\\\\d{2}\",\r\n            cardinality: 4,\r\n            prevalidator: [ {\r\n                validator: \"[12]\",\r\n                cardinality: 1\r\n            }, {\r\n                validator: \"(19|20)\",\r\n                cardinality: 2\r\n            }, {\r\n                validator: \"(19|20)\\\\d\",\r\n                cardinality: 3\r\n            } ]\r\n        }\r\n    }), Inputmask.extendAliases({\r\n        \"dd/mm/yyyy\": {\r\n            mask: \"1/2/y\",\r\n            placeholder: \"dd/mm/yyyy\",\r\n            regex: {\r\n                val1pre: new RegExp(\"[0-3]\"),\r\n                val1: new RegExp(\"0[1-9]|[12][0-9]|3[01]\"),\r\n                val2pre: function(separator) {\r\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\r\n                    return new RegExp(\"((0[1-9]|[12][0-9]|3[01])\" + escapedSeparator + \"[01])\");\r\n                },\r\n                val2: function(separator) {\r\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\r\n                    return new RegExp(\"((0[1-9]|[12][0-9])\" + escapedSeparator + \"(0[1-9]|1[012]))|(30\" + escapedSeparator + \"(0[13-9]|1[012]))|(31\" + escapedSeparator + \"(0[13578]|1[02]))\");\r\n                }\r\n            },\r\n            leapday: \"29/02/\",\r\n            separator: \"/\",\r\n            yearrange: {\r\n                minyear: 1900,\r\n                maxyear: 2099\r\n            },\r\n            isInYearRange: function(chrs, minyear, maxyear) {\r\n                if (isNaN(chrs)) return !1;\r\n                var enteredyear = parseInt(chrs.concat(minyear.toString().slice(chrs.length))), enteredyear2 = parseInt(chrs.concat(maxyear.toString().slice(chrs.length)));\r\n                return !isNaN(enteredyear) && (minyear <= enteredyear && enteredyear <= maxyear) || !isNaN(enteredyear2) && (minyear <= enteredyear2 && enteredyear2 <= maxyear);\r\n            },\r\n            determinebaseyear: function(minyear, maxyear, hint) {\r\n                var currentyear = new Date().getFullYear();\r\n                if (minyear > currentyear) return minyear;\r\n                if (maxyear < currentyear) {\r\n                    for (var maxYearPrefix = maxyear.toString().slice(0, 2), maxYearPostfix = maxyear.toString().slice(2, 4); maxyear < maxYearPrefix + hint; ) maxYearPrefix--;\r\n                    var maxxYear = maxYearPrefix + maxYearPostfix;\r\n                    return minyear > maxxYear ? minyear : maxxYear;\r\n                }\r\n                if (minyear <= currentyear && currentyear <= maxyear) {\r\n                    for (var currentYearPrefix = currentyear.toString().slice(0, 2); maxyear < currentYearPrefix + hint; ) currentYearPrefix--;\r\n                    var currentYearAndHint = currentYearPrefix + hint;\r\n                    return currentYearAndHint < minyear ? minyear : currentYearAndHint;\r\n                }\r\n                return currentyear;\r\n            },\r\n            onKeyDown: function(e, buffer, caretPos, opts) {\r\n                var $input = $(this);\r\n                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\r\n                    var today = new Date();\r\n                    $input.val(today.getDate().toString() + (today.getMonth() + 1).toString() + today.getFullYear().toString()), \r\n                    $input.trigger(\"setvalue\");\r\n                }\r\n            },\r\n            getFrontValue: function(mask, buffer, opts) {\r\n                for (var start = 0, length = 0, i = 0; i < mask.length && \"2\" !== mask.charAt(i); i++) {\r\n                    var definition = opts.definitions[mask.charAt(i)];\r\n                    definition ? (start += length, length = definition.cardinality) : length++;\r\n                }\r\n                return buffer.join(\"\").substr(start, length);\r\n            },\r\n            postValidation: function(buffer, currentResult, opts) {\r\n                var dayMonthValue, year, bufferStr = buffer.join(\"\");\r\n                return 0 === opts.mask.indexOf(\"y\") ? (year = bufferStr.substr(0, 4), dayMonthValue = bufferStr.substr(4, 11)) : (year = bufferStr.substr(6, 11), \r\n                dayMonthValue = bufferStr.substr(0, 6)), currentResult && (dayMonthValue !== opts.leapday || isLeapYear(year));\r\n            },\r\n            definitions: {\r\n                \"1\": {\r\n                    validator: function(chrs, maskset, pos, strict, opts) {\r\n                        var isValid = opts.regex.val1.test(chrs);\r\n                        return strict || isValid || chrs.charAt(1) !== opts.separator && \"-./\".indexOf(chrs.charAt(1)) === -1 || !(isValid = opts.regex.val1.test(\"0\" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = \"0\", \r\n                        {\r\n                            refreshFromBuffer: {\r\n                                start: pos - 1,\r\n                                end: pos\r\n                            },\r\n                            pos: pos,\r\n                            c: chrs.charAt(0)\r\n                        });\r\n                    },\r\n                    cardinality: 2,\r\n                    prevalidator: [ {\r\n                        validator: function(chrs, maskset, pos, strict, opts) {\r\n                            var pchrs = chrs;\r\n                            isNaN(maskset.buffer[pos + 1]) || (pchrs += maskset.buffer[pos + 1]);\r\n                            var isValid = 1 === pchrs.length ? opts.regex.val1pre.test(pchrs) : opts.regex.val1.test(pchrs);\r\n                            if (!strict && !isValid) {\r\n                                if (isValid = opts.regex.val1.test(chrs + \"0\")) return maskset.buffer[pos] = chrs, \r\n                                maskset.buffer[++pos] = \"0\", {\r\n                                    pos: pos,\r\n                                    c: \"0\"\r\n                                };\r\n                                if (isValid = opts.regex.val1.test(\"0\" + chrs)) return maskset.buffer[pos] = \"0\", \r\n                                pos++, {\r\n                                    pos: pos\r\n                                };\r\n                            }\r\n                            return isValid;\r\n                        },\r\n                        cardinality: 1\r\n                    } ]\r\n                },\r\n                \"2\": {\r\n                    validator: function(chrs, maskset, pos, strict, opts) {\r\n                        var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);\r\n                        frontValue.indexOf(opts.placeholder[0]) !== -1 && (frontValue = \"01\" + opts.separator);\r\n                        var isValid = opts.regex.val2(opts.separator).test(frontValue + chrs);\r\n                        return strict || isValid || chrs.charAt(1) !== opts.separator && \"-./\".indexOf(chrs.charAt(1)) === -1 || !(isValid = opts.regex.val2(opts.separator).test(frontValue + \"0\" + chrs.charAt(0))) ? isValid : (maskset.buffer[pos - 1] = \"0\", \r\n                        {\r\n                            refreshFromBuffer: {\r\n                                start: pos - 1,\r\n                                end: pos\r\n                            },\r\n                            pos: pos,\r\n                            c: chrs.charAt(0)\r\n                        });\r\n                    },\r\n                    cardinality: 2,\r\n                    prevalidator: [ {\r\n                        validator: function(chrs, maskset, pos, strict, opts) {\r\n                            isNaN(maskset.buffer[pos + 1]) || (chrs += maskset.buffer[pos + 1]);\r\n                            var frontValue = opts.getFrontValue(maskset.mask, maskset.buffer, opts);\r\n                            frontValue.indexOf(opts.placeholder[0]) !== -1 && (frontValue = \"01\" + opts.separator);\r\n                            var isValid = 1 === chrs.length ? opts.regex.val2pre(opts.separator).test(frontValue + chrs) : opts.regex.val2(opts.separator).test(frontValue + chrs);\r\n                            return strict || isValid || !(isValid = opts.regex.val2(opts.separator).test(frontValue + \"0\" + chrs)) ? isValid : (maskset.buffer[pos] = \"0\", \r\n                            pos++, {\r\n                                pos: pos\r\n                            });\r\n                        },\r\n                        cardinality: 1\r\n                    } ]\r\n                },\r\n                y: {\r\n                    validator: function(chrs, maskset, pos, strict, opts) {\r\n                        return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\r\n                    },\r\n                    cardinality: 4,\r\n                    prevalidator: [ {\r\n                        validator: function(chrs, maskset, pos, strict, opts) {\r\n                            var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\r\n                            if (!strict && !isValid) {\r\n                                var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + \"0\").toString().slice(0, 1);\r\n                                if (isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0), \r\n                                {\r\n                                    pos: pos\r\n                                };\r\n                                if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs + \"0\").toString().slice(0, 2), \r\n                                isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(0), \r\n                                maskset.buffer[pos++] = yearPrefix.charAt(1), {\r\n                                    pos: pos\r\n                                };\r\n                            }\r\n                            return isValid;\r\n                        },\r\n                        cardinality: 1\r\n                    }, {\r\n                        validator: function(chrs, maskset, pos, strict, opts) {\r\n                            var isValid = opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\r\n                            if (!strict && !isValid) {\r\n                                var yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2);\r\n                                if (isValid = opts.isInYearRange(chrs[0] + yearPrefix[1] + chrs[1], opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos++] = yearPrefix.charAt(1), \r\n                                {\r\n                                    pos: pos\r\n                                };\r\n                                if (yearPrefix = opts.determinebaseyear(opts.yearrange.minyear, opts.yearrange.maxyear, chrs).toString().slice(0, 2), \r\n                                isValid = opts.isInYearRange(yearPrefix + chrs, opts.yearrange.minyear, opts.yearrange.maxyear)) return maskset.buffer[pos - 1] = yearPrefix.charAt(0), \r\n                                maskset.buffer[pos++] = yearPrefix.charAt(1), maskset.buffer[pos++] = chrs.charAt(0), \r\n                                {\r\n                                    refreshFromBuffer: {\r\n                                        start: pos - 3,\r\n                                        end: pos\r\n                                    },\r\n                                    pos: pos\r\n                                };\r\n                            }\r\n                            return isValid;\r\n                        },\r\n                        cardinality: 2\r\n                    }, {\r\n                        validator: function(chrs, maskset, pos, strict, opts) {\r\n                            return opts.isInYearRange(chrs, opts.yearrange.minyear, opts.yearrange.maxyear);\r\n                        },\r\n                        cardinality: 3\r\n                    } ]\r\n                }\r\n            },\r\n            insertMode: !1,\r\n            autoUnmask: !1\r\n        },\r\n        \"mm/dd/yyyy\": {\r\n            placeholder: \"mm/dd/yyyy\",\r\n            alias: \"dd/mm/yyyy\",\r\n            regex: {\r\n                val2pre: function(separator) {\r\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\r\n                    return new RegExp(\"((0[13-9]|1[012])\" + escapedSeparator + \"[0-3])|(02\" + escapedSeparator + \"[0-2])\");\r\n                },\r\n                val2: function(separator) {\r\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\r\n                    return new RegExp(\"((0[1-9]|1[012])\" + escapedSeparator + \"(0[1-9]|[12][0-9]))|((0[13-9]|1[012])\" + escapedSeparator + \"30)|((0[13578]|1[02])\" + escapedSeparator + \"31)\");\r\n                },\r\n                val1pre: new RegExp(\"[01]\"),\r\n                val1: new RegExp(\"0[1-9]|1[012]\")\r\n            },\r\n            leapday: \"02/29/\",\r\n            onKeyDown: function(e, buffer, caretPos, opts) {\r\n                var $input = $(this);\r\n                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\r\n                    var today = new Date();\r\n                    $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()), \r\n                    $input.trigger(\"setvalue\");\r\n                }\r\n            }\r\n        },\r\n        \"yyyy/mm/dd\": {\r\n            mask: \"y/1/2\",\r\n            placeholder: \"yyyy/mm/dd\",\r\n            alias: \"mm/dd/yyyy\",\r\n            leapday: \"/02/29\",\r\n            onKeyDown: function(e, buffer, caretPos, opts) {\r\n                var $input = $(this);\r\n                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\r\n                    var today = new Date();\r\n                    $input.val(today.getFullYear().toString() + (today.getMonth() + 1).toString() + today.getDate().toString()), \r\n                    $input.trigger(\"setvalue\");\r\n                }\r\n            }\r\n        },\r\n        \"dd.mm.yyyy\": {\r\n            mask: \"1.2.y\",\r\n            placeholder: \"dd.mm.yyyy\",\r\n            leapday: \"29.02.\",\r\n            separator: \".\",\r\n            alias: \"dd/mm/yyyy\"\r\n        },\r\n        \"dd-mm-yyyy\": {\r\n            mask: \"1-2-y\",\r\n            placeholder: \"dd-mm-yyyy\",\r\n            leapday: \"29-02-\",\r\n            separator: \"-\",\r\n            alias: \"dd/mm/yyyy\"\r\n        },\r\n        \"mm.dd.yyyy\": {\r\n            mask: \"1.2.y\",\r\n            placeholder: \"mm.dd.yyyy\",\r\n            leapday: \"02.29.\",\r\n            separator: \".\",\r\n            alias: \"mm/dd/yyyy\"\r\n        },\r\n        \"mm-dd-yyyy\": {\r\n            mask: \"1-2-y\",\r\n            placeholder: \"mm-dd-yyyy\",\r\n            leapday: \"02-29-\",\r\n            separator: \"-\",\r\n            alias: \"mm/dd/yyyy\"\r\n        },\r\n        \"yyyy.mm.dd\": {\r\n            mask: \"y.1.2\",\r\n            placeholder: \"yyyy.mm.dd\",\r\n            leapday: \".02.29\",\r\n            separator: \".\",\r\n            alias: \"yyyy/mm/dd\"\r\n        },\r\n        \"yyyy-mm-dd\": {\r\n            mask: \"y-1-2\",\r\n            placeholder: \"yyyy-mm-dd\",\r\n            leapday: \"-02-29\",\r\n            separator: \"-\",\r\n            alias: \"yyyy/mm/dd\"\r\n        },\r\n        datetime: {\r\n            mask: \"1/2/y h:s\",\r\n            placeholder: \"dd/mm/yyyy hh:mm\",\r\n            alias: \"dd/mm/yyyy\",\r\n            regex: {\r\n                hrspre: new RegExp(\"[012]\"),\r\n                hrs24: new RegExp(\"2[0-4]|1[3-9]\"),\r\n                hrs: new RegExp(\"[01][0-9]|2[0-4]\"),\r\n                ampm: new RegExp(\"^[a|p|A|P][m|M]\"),\r\n                mspre: new RegExp(\"[0-5]\"),\r\n                ms: new RegExp(\"[0-5][0-9]\")\r\n            },\r\n            timeseparator: \":\",\r\n            hourFormat: \"24\",\r\n            definitions: {\r\n                h: {\r\n                    validator: function(chrs, maskset, pos, strict, opts) {\r\n                        if (\"24\" === opts.hourFormat && 24 === parseInt(chrs, 10)) return maskset.buffer[pos - 1] = \"0\", \r\n                        maskset.buffer[pos] = \"0\", {\r\n                            refreshFromBuffer: {\r\n                                start: pos - 1,\r\n                                end: pos\r\n                            },\r\n                            c: \"0\"\r\n                        };\r\n                        var isValid = opts.regex.hrs.test(chrs);\r\n                        if (!strict && !isValid && (chrs.charAt(1) === opts.timeseparator || \"-.:\".indexOf(chrs.charAt(1)) !== -1) && (isValid = opts.regex.hrs.test(\"0\" + chrs.charAt(0)))) return maskset.buffer[pos - 1] = \"0\", \r\n                        maskset.buffer[pos] = chrs.charAt(0), pos++, {\r\n                            refreshFromBuffer: {\r\n                                start: pos - 2,\r\n                                end: pos\r\n                            },\r\n                            pos: pos,\r\n                            c: opts.timeseparator\r\n                        };\r\n                        if (isValid && \"24\" !== opts.hourFormat && opts.regex.hrs24.test(chrs)) {\r\n                            var tmp = parseInt(chrs, 10);\r\n                            return 24 === tmp ? (maskset.buffer[pos + 5] = \"a\", maskset.buffer[pos + 6] = \"m\") : (maskset.buffer[pos + 5] = \"p\", \r\n                            maskset.buffer[pos + 6] = \"m\"), tmp -= 12, tmp < 10 ? (maskset.buffer[pos] = tmp.toString(), \r\n                            maskset.buffer[pos - 1] = \"0\") : (maskset.buffer[pos] = tmp.toString().charAt(1), \r\n                            maskset.buffer[pos - 1] = tmp.toString().charAt(0)), {\r\n                                refreshFromBuffer: {\r\n                                    start: pos - 1,\r\n                                    end: pos + 6\r\n                                },\r\n                                c: maskset.buffer[pos]\r\n                            };\r\n                        }\r\n                        return isValid;\r\n                    },\r\n                    cardinality: 2,\r\n                    prevalidator: [ {\r\n                        validator: function(chrs, maskset, pos, strict, opts) {\r\n                            var isValid = opts.regex.hrspre.test(chrs);\r\n                            return strict || isValid || !(isValid = opts.regex.hrs.test(\"0\" + chrs)) ? isValid : (maskset.buffer[pos] = \"0\", \r\n                            pos++, {\r\n                                pos: pos\r\n                            });\r\n                        },\r\n                        cardinality: 1\r\n                    } ]\r\n                },\r\n                s: {\r\n                    validator: \"[0-5][0-9]\",\r\n                    cardinality: 2,\r\n                    prevalidator: [ {\r\n                        validator: function(chrs, maskset, pos, strict, opts) {\r\n                            var isValid = opts.regex.mspre.test(chrs);\r\n                            return strict || isValid || !(isValid = opts.regex.ms.test(\"0\" + chrs)) ? isValid : (maskset.buffer[pos] = \"0\", \r\n                            pos++, {\r\n                                pos: pos\r\n                            });\r\n                        },\r\n                        cardinality: 1\r\n                    } ]\r\n                },\r\n                t: {\r\n                    validator: function(chrs, maskset, pos, strict, opts) {\r\n                        return opts.regex.ampm.test(chrs + \"m\");\r\n                    },\r\n                    casing: \"lower\",\r\n                    cardinality: 1\r\n                }\r\n            },\r\n            insertMode: !1,\r\n            autoUnmask: !1\r\n        },\r\n        datetime12: {\r\n            mask: \"1/2/y h:s t\\\\m\",\r\n            placeholder: \"dd/mm/yyyy hh:mm xm\",\r\n            alias: \"datetime\",\r\n            hourFormat: \"12\"\r\n        },\r\n        \"mm/dd/yyyy hh:mm xm\": {\r\n            mask: \"1/2/y h:s t\\\\m\",\r\n            placeholder: \"mm/dd/yyyy hh:mm xm\",\r\n            alias: \"datetime12\",\r\n            regex: {\r\n                val2pre: function(separator) {\r\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\r\n                    return new RegExp(\"((0[13-9]|1[012])\" + escapedSeparator + \"[0-3])|(02\" + escapedSeparator + \"[0-2])\");\r\n                },\r\n                val2: function(separator) {\r\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\r\n                    return new RegExp(\"((0[1-9]|1[012])\" + escapedSeparator + \"(0[1-9]|[12][0-9]))|((0[13-9]|1[012])\" + escapedSeparator + \"30)|((0[13578]|1[02])\" + escapedSeparator + \"31)\");\r\n                },\r\n                val1pre: new RegExp(\"[01]\"),\r\n                val1: new RegExp(\"0[1-9]|1[012]\")\r\n            },\r\n            leapday: \"02/29/\",\r\n            onKeyDown: function(e, buffer, caretPos, opts) {\r\n                var $input = $(this);\r\n                if (e.ctrlKey && e.keyCode === Inputmask.keyCode.RIGHT) {\r\n                    var today = new Date();\r\n                    $input.val((today.getMonth() + 1).toString() + today.getDate().toString() + today.getFullYear().toString()), \r\n                    $input.trigger(\"setvalue\");\r\n                }\r\n            }\r\n        },\r\n        \"hh:mm t\": {\r\n            mask: \"h:s t\\\\m\",\r\n            placeholder: \"hh:mm xm\",\r\n            alias: \"datetime\",\r\n            hourFormat: \"12\"\r\n        },\r\n        \"h:s t\": {\r\n            mask: \"h:s t\\\\m\",\r\n            placeholder: \"hh:mm xm\",\r\n            alias: \"datetime\",\r\n            hourFormat: \"12\"\r\n        },\r\n        \"hh:mm:ss\": {\r\n            mask: \"h:s:s\",\r\n            placeholder: \"hh:mm:ss\",\r\n            alias: \"datetime\",\r\n            autoUnmask: !1\r\n        },\r\n        \"hh:mm\": {\r\n            mask: \"h:s\",\r\n            placeholder: \"hh:mm\",\r\n            alias: \"datetime\",\r\n            autoUnmask: !1\r\n        },\r\n        date: {\r\n            alias: \"dd/mm/yyyy\"\r\n        },\r\n        \"mm/yyyy\": {\r\n            mask: \"1/y\",\r\n            placeholder: \"mm/yyyy\",\r\n            leapday: \"donotuse\",\r\n            separator: \"/\",\r\n            alias: \"mm/dd/yyyy\"\r\n        },\r\n        shamsi: {\r\n            regex: {\r\n                val2pre: function(separator) {\r\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\r\n                    return new RegExp(\"((0[1-9]|1[012])\" + escapedSeparator + \"[0-3])\");\r\n                },\r\n                val2: function(separator) {\r\n                    var escapedSeparator = Inputmask.escapeRegex.call(this, separator);\r\n                    return new RegExp(\"((0[1-9]|1[012])\" + escapedSeparator + \"(0[1-9]|[12][0-9]))|((0[1-9]|1[012])\" + escapedSeparator + \"30)|((0[1-6])\" + escapedSeparator + \"31)\");\r\n                },\r\n                val1pre: new RegExp(\"[01]\"),\r\n                val1: new RegExp(\"0[1-9]|1[012]\")\r\n            },\r\n            yearrange: {\r\n                minyear: 1300,\r\n                maxyear: 1499\r\n            },\r\n            mask: \"y/1/2\",\r\n            leapday: \"/12/30\",\r\n            placeholder: \"yyyy/mm/dd\",\r\n            alias: \"mm/dd/yyyy\",\r\n            clearIncomplete: !0\r\n        }\r\n    }), Inputmask;\r\n}(jQuery, Inputmask), function($, Inputmask) {\r\n    return Inputmask.extendDefinitions({\r\n        A: {\r\n            validator: \"[A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\r\n            cardinality: 1,\r\n            casing: \"upper\"\r\n        },\r\n        \"&\": {\r\n            validator: \"[0-9A-Za-z\\u0410-\\u044f\\u0401\\u0451\\xc0-\\xff\\xb5]\",\r\n            cardinality: 1,\r\n            casing: \"upper\"\r\n        },\r\n        \"#\": {\r\n            validator: \"[0-9A-Fa-f]\",\r\n            cardinality: 1,\r\n            casing: \"upper\"\r\n        }\r\n    }), Inputmask.extendAliases({\r\n        url: {\r\n            definitions: {\r\n                i: {\r\n                    validator: \".\",\r\n                    cardinality: 1\r\n                }\r\n            },\r\n            mask: \"(\\\\http://)|(\\\\http\\\\s://)|(ftp://)|(ftp\\\\s://)i{+}\",\r\n            insertMode: !1,\r\n            autoUnmask: !1,\r\n            inputmode: \"url\"\r\n        },\r\n        ip: {\r\n            mask: \"i[i[i]].i[i[i]].i[i[i]].i[i[i]]\",\r\n            definitions: {\r\n                i: {\r\n                    validator: function(chrs, maskset, pos, strict, opts) {\r\n                        return pos - 1 > -1 && \".\" !== maskset.buffer[pos - 1] ? (chrs = maskset.buffer[pos - 1] + chrs, \r\n                        chrs = pos - 2 > -1 && \".\" !== maskset.buffer[pos - 2] ? maskset.buffer[pos - 2] + chrs : \"0\" + chrs) : chrs = \"00\" + chrs, \r\n                        new RegExp(\"25[0-5]|2[0-4][0-9]|[01][0-9][0-9]\").test(chrs);\r\n                    },\r\n                    cardinality: 1\r\n                }\r\n            },\r\n            onUnMask: function(maskedValue, unmaskedValue, opts) {\r\n                return maskedValue;\r\n            },\r\n            inputmode: \"numeric\"\r\n        },\r\n        email: {\r\n            mask: \"*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]\",\r\n            greedy: !1,\r\n            onBeforePaste: function(pastedValue, opts) {\r\n                return pastedValue = pastedValue.toLowerCase(), pastedValue.replace(\"mailto:\", \"\");\r\n            },\r\n            definitions: {\r\n                \"*\": {\r\n                    validator: \"[0-9A-Za-z!#$%&'*+/=?^_`{|}~-]\",\r\n                    cardinality: 1,\r\n                    casing: \"lower\"\r\n                },\r\n                \"-\": {\r\n                    validator: \"[0-9A-Za-z-]\",\r\n                    cardinality: 1,\r\n                    casing: \"lower\"\r\n                }\r\n            },\r\n            onUnMask: function(maskedValue, unmaskedValue, opts) {\r\n                return maskedValue;\r\n            },\r\n            inputmode: \"email\"\r\n        },\r\n        mac: {\r\n            mask: \"##:##:##:##:##:##\"\r\n        },\r\n        vin: {\r\n            mask: \"V{13}9{4}\",\r\n            definitions: {\r\n                V: {\r\n                    validator: \"[A-HJ-NPR-Za-hj-npr-z\\\\d]\",\r\n                    cardinality: 1,\r\n                    casing: \"upper\"\r\n                }\r\n            },\r\n            clearIncomplete: !0,\r\n            autoUnmask: !0\r\n        }\r\n    }), Inputmask;\r\n}(jQuery, Inputmask), function($, Inputmask) {\r\n    return Inputmask.extendAliases({\r\n        numeric: {\r\n            mask: function(opts) {\r\n                function autoEscape(txt) {\r\n                    for (var escapedTxt = \"\", i = 0; i < txt.length; i++) escapedTxt += opts.definitions[txt.charAt(i)] || opts.optionalmarker.start === txt.charAt(i) || opts.optionalmarker.end === txt.charAt(i) || opts.quantifiermarker.start === txt.charAt(i) || opts.quantifiermarker.end === txt.charAt(i) || opts.groupmarker.start === txt.charAt(i) || opts.groupmarker.end === txt.charAt(i) || opts.alternatormarker === txt.charAt(i) ? \"\\\\\" + txt.charAt(i) : txt.charAt(i);\r\n                    return escapedTxt;\r\n                }\r\n                if (0 !== opts.repeat && isNaN(opts.integerDigits) && (opts.integerDigits = opts.repeat), \r\n                opts.repeat = 0, opts.groupSeparator === opts.radixPoint && (\".\" === opts.radixPoint ? opts.groupSeparator = \",\" : \",\" === opts.radixPoint ? opts.groupSeparator = \".\" : opts.groupSeparator = \"\"), \r\n                \" \" === opts.groupSeparator && (opts.skipOptionalPartCharacter = void 0), opts.autoGroup = opts.autoGroup && \"\" !== opts.groupSeparator, \r\n                opts.autoGroup && (\"string\" == typeof opts.groupSize && isFinite(opts.groupSize) && (opts.groupSize = parseInt(opts.groupSize)), \r\n                isFinite(opts.integerDigits))) {\r\n                    var seps = Math.floor(opts.integerDigits / opts.groupSize), mod = opts.integerDigits % opts.groupSize;\r\n                    opts.integerDigits = parseInt(opts.integerDigits) + (0 === mod ? seps - 1 : seps), \r\n                    opts.integerDigits < 1 && (opts.integerDigits = \"*\");\r\n                }\r\n                opts.placeholder.length > 1 && (opts.placeholder = opts.placeholder.charAt(0)), \r\n                \"radixFocus\" === opts.positionCaretOnClick && \"\" === opts.placeholder && opts.integerOptional === !1 && (opts.positionCaretOnClick = \"lvp\"), \r\n                opts.definitions[\";\"] = opts.definitions[\"~\"], opts.definitions[\";\"].definitionSymbol = \"~\", \r\n                opts.numericInput === !0 && (opts.positionCaretOnClick = \"radixFocus\" === opts.positionCaretOnClick ? \"lvp\" : opts.positionCaretOnClick, \r\n                opts.digitsOptional = !1, isNaN(opts.digits) && (opts.digits = 2), opts.decimalProtect = !1);\r\n                var mask = \"[+]\";\r\n                if (mask += autoEscape(opts.prefix), mask += opts.integerOptional === !0 ? \"~{1,\" + opts.integerDigits + \"}\" : \"~{\" + opts.integerDigits + \"}\", \r\n                void 0 !== opts.digits) {\r\n                    opts.decimalProtect && (opts.radixPointDefinitionSymbol = \":\");\r\n                    var dq = opts.digits.toString().split(\",\");\r\n                    isFinite(dq[0] && dq[1] && isFinite(dq[1])) ? mask += (opts.decimalProtect ? \":\" : opts.radixPoint) + \";{\" + opts.digits + \"}\" : (isNaN(opts.digits) || parseInt(opts.digits) > 0) && (mask += opts.digitsOptional ? \"[\" + (opts.decimalProtect ? \":\" : opts.radixPoint) + \";{1,\" + opts.digits + \"}]\" : (opts.decimalProtect ? \":\" : opts.radixPoint) + \";{\" + opts.digits + \"}\");\r\n                }\r\n                return mask += autoEscape(opts.suffix), mask += \"[-]\", opts.greedy = !1, null !== opts.min && (opts.min = opts.min.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \r\n                \",\" === opts.radixPoint && (opts.min = opts.min.replace(opts.radixPoint, \".\"))), \r\n                null !== opts.max && (opts.max = opts.max.toString().replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \r\n                \",\" === opts.radixPoint && (opts.max = opts.max.replace(opts.radixPoint, \".\"))), \r\n                mask;\r\n            },\r\n            placeholder: \"\",\r\n            greedy: !1,\r\n            digits: \"*\",\r\n            digitsOptional: !0,\r\n            radixPoint: \".\",\r\n            positionCaretOnClick: \"radixFocus\",\r\n            groupSize: 3,\r\n            groupSeparator: \"\",\r\n            autoGroup: !1,\r\n            allowPlus: !0,\r\n            allowMinus: !0,\r\n            negationSymbol: {\r\n                front: \"-\",\r\n                back: \"\"\r\n            },\r\n            integerDigits: \"+\",\r\n            integerOptional: !0,\r\n            prefix: \"\",\r\n            suffix: \"\",\r\n            rightAlign: !0,\r\n            decimalProtect: !0,\r\n            min: null,\r\n            max: null,\r\n            step: 1,\r\n            insertMode: !0,\r\n            autoUnmask: !1,\r\n            unmaskAsNumber: !1,\r\n            inputmode: \"numeric\",\r\n            postFormat: function(buffer, pos, opts) {\r\n                opts.numericInput === !0 && (buffer = buffer.reverse(), isFinite(pos) && (pos = buffer.join(\"\").length - pos - 1));\r\n                var i, l;\r\n                pos = pos >= buffer.length ? buffer.length - 1 : pos < 0 ? 0 : pos;\r\n                var charAtPos = buffer[pos], cbuf = buffer.slice();\r\n                charAtPos === opts.groupSeparator && (cbuf.splice(pos--, 1), charAtPos = cbuf[pos]);\r\n                var isNegative = cbuf.join(\"\").match(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)));\r\n                isNegative = null !== isNegative && 1 === isNegative.length, pos > (isNegative ? opts.negationSymbol.front.length : 0) + opts.prefix.length && pos < cbuf.length - opts.suffix.length && (cbuf[pos] = \"!\");\r\n                var bufVal = cbuf.join(\"\"), bufValOrigin = cbuf.join();\r\n                if (isNegative && (bufVal = bufVal.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.negationSymbol.front)), \"\"), \r\n                bufVal = bufVal.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\")), \r\n                bufVal = bufVal.replace(new RegExp(Inputmask.escapeRegex(opts.suffix) + \"$\"), \"\"), \r\n                bufVal = bufVal.replace(new RegExp(\"^\" + Inputmask.escapeRegex(opts.prefix)), \"\"), \r\n                bufVal.length > 0 && opts.autoGroup || bufVal.indexOf(opts.groupSeparator) !== -1) {\r\n                    var escapedGroupSeparator = Inputmask.escapeRegex(opts.groupSeparator);\r\n                    bufVal = bufVal.replace(new RegExp(escapedGroupSeparator, \"g\"), \"\");\r\n                    var radixSplit = bufVal.split(charAtPos === opts.radixPoint ? \"!\" : opts.radixPoint);\r\n                    if (bufVal = \"\" === opts.radixPoint ? bufVal : radixSplit[0], charAtPos !== opts.negationSymbol.front && (bufVal = bufVal.replace(\"!\", \"?\")), \r\n                    bufVal.length > opts.groupSize) for (var reg = new RegExp(\"([-+]?[\\\\d?]+)([\\\\d?]{\" + opts.groupSize + \"})\"); reg.test(bufVal) && \"\" !== opts.groupSeparator; ) bufVal = bufVal.replace(reg, \"$1\" + opts.groupSeparator + \"$2\"), \r\n                    bufVal = bufVal.replace(opts.groupSeparator + opts.groupSeparator, opts.groupSeparator);\r\n                    bufVal = bufVal.replace(\"?\", \"!\"), \"\" !== opts.radixPoint && radixSplit.length > 1 && (bufVal += (charAtPos === opts.radixPoint ? \"!\" : opts.radixPoint) + radixSplit[1]);\r\n                }\r\n                bufVal = opts.prefix + bufVal + opts.suffix, isNegative && (bufVal = opts.negationSymbol.front + bufVal + opts.negationSymbol.back);\r\n                var needsRefresh = bufValOrigin !== bufVal.split(\"\").join(), newPos = $.inArray(\"!\", bufVal);\r\n                if (newPos === -1 && (newPos = pos), needsRefresh) {\r\n                    for (buffer.length = bufVal.length, i = 0, l = bufVal.length; i < l; i++) buffer[i] = bufVal.charAt(i);\r\n                    buffer[newPos] = charAtPos;\r\n                }\r\n                return newPos = opts.numericInput && isFinite(pos) ? buffer.join(\"\").length - newPos - 1 : newPos, \r\n                opts.numericInput && (buffer = buffer.reverse(), $.inArray(opts.radixPoint, buffer) < newPos && buffer.join(\"\").length - opts.suffix.length !== newPos && (newPos -= 1)), \r\n                {\r\n                    pos: newPos,\r\n                    refreshFromBuffer: needsRefresh,\r\n                    buffer: buffer,\r\n                    isNegative: isNegative\r\n                };\r\n            },\r\n            onBeforeWrite: function(e, buffer, caretPos, opts) {\r\n                var rslt;\r\n                if (e && (\"blur\" === e.type || \"checkval\" === e.type || \"keydown\" === e.type)) {\r\n                    var maskedValue = opts.numericInput ? buffer.slice().reverse().join(\"\") : buffer.join(\"\"), processValue = maskedValue.replace(opts.prefix, \"\");\r\n                    processValue = processValue.replace(opts.suffix, \"\"), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \r\n                    \",\" === opts.radixPoint && (processValue = processValue.replace(opts.radixPoint, \".\"));\r\n                    var isNegative = processValue.match(new RegExp(\"[-\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"]\", \"g\"));\r\n                    if (isNegative = null !== isNegative && 1 === isNegative.length, processValue = processValue.replace(new RegExp(\"[-\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"]\", \"g\"), \"\"), \r\n                    processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.negationSymbol.back) + \"$\"), \"\"), \r\n                    isNaN(opts.placeholder) && (processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.placeholder), \"g\"), \"\")), \r\n                    processValue = processValue === opts.negationSymbol.front ? processValue + \"0\" : processValue, \r\n                    \"\" !== processValue && isFinite(processValue)) {\r\n                        var floatValue = parseFloat(processValue), signedFloatValue = isNegative ? floatValue * -1 : floatValue;\r\n                        if (null !== opts.min && isFinite(opts.min) && signedFloatValue < parseFloat(opts.min) ? (floatValue = Math.abs(opts.min), \r\n                        isNegative = opts.min < 0, maskedValue = void 0) : null !== opts.max && isFinite(opts.max) && signedFloatValue > parseFloat(opts.max) && (floatValue = Math.abs(opts.max), \r\n                        isNegative = opts.max < 0, maskedValue = void 0), processValue = floatValue.toString().replace(\".\", opts.radixPoint).split(\"\"), \r\n                        isFinite(opts.digits)) {\r\n                            var radixPosition = $.inArray(opts.radixPoint, processValue), rpb = $.inArray(opts.radixPoint, maskedValue);\r\n                            radixPosition === -1 && (processValue.push(opts.radixPoint), radixPosition = processValue.length - 1);\r\n                            for (var i = 1; i <= opts.digits; i++) opts.digitsOptional || void 0 !== processValue[radixPosition + i] && processValue[radixPosition + i] !== opts.placeholder.charAt(0) ? rpb !== -1 && void 0 !== maskedValue[rpb + i] && (processValue[radixPosition + i] = processValue[radixPosition + i] || maskedValue[rpb + i]) : processValue[radixPosition + i] = \"0\";\r\n                            processValue[processValue.length - 1] === opts.radixPoint && delete processValue[processValue.length - 1];\r\n                        }\r\n                        if (floatValue.toString() !== processValue && floatValue.toString() + \".\" !== processValue || isNegative) return processValue = (opts.prefix + processValue.join(\"\")).split(\"\"), \r\n                        !isNegative || 0 === floatValue && \"blur\" === e.type || (processValue.unshift(opts.negationSymbol.front), \r\n                        processValue.push(opts.negationSymbol.back)), opts.numericInput && (processValue = processValue.reverse()), \r\n                        rslt = opts.postFormat(processValue, opts.numericInput ? caretPos : caretPos - 1, opts), \r\n                        rslt.buffer && (rslt.refreshFromBuffer = rslt.buffer.join(\"\") !== buffer.join(\"\")), \r\n                        rslt;\r\n                    }\r\n                }\r\n                if (opts.autoGroup) return rslt = opts.postFormat(buffer, opts.numericInput ? caretPos : caretPos - 1, opts), \r\n                rslt.caret = caretPos < (rslt.isNegative ? opts.negationSymbol.front.length : 0) + opts.prefix.length || caretPos > rslt.buffer.length - (rslt.isNegative ? opts.negationSymbol.back.length : 0) ? rslt.pos : rslt.pos + 1, \r\n                rslt;\r\n            },\r\n            regex: {\r\n                integerPart: function(opts) {\r\n                    return new RegExp(\"[\" + Inputmask.escapeRegex(opts.negationSymbol.front) + \"+]?\\\\d+\");\r\n                },\r\n                integerNPart: function(opts) {\r\n                    return new RegExp(\"[\\\\d\" + Inputmask.escapeRegex(opts.groupSeparator) + Inputmask.escapeRegex(opts.placeholder.charAt(0)) + \"]+\");\r\n                }\r\n            },\r\n            signHandler: function(chrs, maskset, pos, strict, opts) {\r\n                if (!strict && opts.allowMinus && \"-\" === chrs || opts.allowPlus && \"+\" === chrs) {\r\n                    var matchRslt = maskset.buffer.join(\"\").match(opts.regex.integerPart(opts));\r\n                    if (matchRslt && matchRslt[0].length > 0) return maskset.buffer[matchRslt.index] === (\"-\" === chrs ? \"+\" : opts.negationSymbol.front) ? \"-\" === chrs ? \"\" !== opts.negationSymbol.back ? {\r\n                        pos: 0,\r\n                        c: opts.negationSymbol.front,\r\n                        remove: 0,\r\n                        caret: pos,\r\n                        insert: {\r\n                            pos: maskset.buffer.length - 1,\r\n                            c: opts.negationSymbol.back\r\n                        }\r\n                    } : {\r\n                        pos: 0,\r\n                        c: opts.negationSymbol.front,\r\n                        remove: 0,\r\n                        caret: pos\r\n                    } : \"\" !== opts.negationSymbol.back ? {\r\n                        pos: 0,\r\n                        c: \"+\",\r\n                        remove: [ 0, maskset.buffer.length - 1 ],\r\n                        caret: pos\r\n                    } : {\r\n                        pos: 0,\r\n                        c: \"+\",\r\n                        remove: 0,\r\n                        caret: pos\r\n                    } : maskset.buffer[0] === (\"-\" === chrs ? opts.negationSymbol.front : \"+\") ? \"-\" === chrs && \"\" !== opts.negationSymbol.back ? {\r\n                        remove: [ 0, maskset.buffer.length - 1 ],\r\n                        caret: pos - 1\r\n                    } : {\r\n                        remove: 0,\r\n                        caret: pos - 1\r\n                    } : \"-\" === chrs ? \"\" !== opts.negationSymbol.back ? {\r\n                        pos: 0,\r\n                        c: opts.negationSymbol.front,\r\n                        caret: pos + 1,\r\n                        insert: {\r\n                            pos: maskset.buffer.length,\r\n                            c: opts.negationSymbol.back\r\n                        }\r\n                    } : {\r\n                        pos: 0,\r\n                        c: opts.negationSymbol.front,\r\n                        caret: pos + 1\r\n                    } : {\r\n                        pos: 0,\r\n                        c: chrs,\r\n                        caret: pos + 1\r\n                    };\r\n                }\r\n                return !1;\r\n            },\r\n            radixHandler: function(chrs, maskset, pos, strict, opts) {\r\n                if (!strict && opts.numericInput !== !0 && chrs === opts.radixPoint && void 0 !== opts.digits && (isNaN(opts.digits) || parseInt(opts.digits) > 0)) {\r\n                    var radixPos = $.inArray(opts.radixPoint, maskset.buffer), integerValue = maskset.buffer.join(\"\").match(opts.regex.integerPart(opts));\r\n                    if (radixPos !== -1 && maskset.validPositions[radixPos]) return maskset.validPositions[radixPos - 1] ? {\r\n                        caret: radixPos + 1\r\n                    } : {\r\n                        pos: integerValue.index,\r\n                        c: integerValue[0],\r\n                        caret: radixPos + 1\r\n                    };\r\n                    if (!integerValue || \"0\" === integerValue[0] && integerValue.index + 1 !== pos) return maskset.buffer[integerValue ? integerValue.index : pos] = \"0\", \r\n                    {\r\n                        pos: (integerValue ? integerValue.index : pos) + 1,\r\n                        c: opts.radixPoint\r\n                    };\r\n                }\r\n                return !1;\r\n            },\r\n            leadingZeroHandler: function(chrs, maskset, pos, strict, opts, isSelection) {\r\n                if (!strict) {\r\n                    var buffer = maskset.buffer.slice(\"\");\r\n                    if (buffer.splice(0, opts.prefix.length), buffer.splice(buffer.length - opts.suffix.length, opts.suffix.length), \r\n                    opts.numericInput === !0) {\r\n                        var buffer = buffer.reverse(), bufferChar = buffer[0];\r\n                        if (\"0\" === bufferChar && void 0 === maskset.validPositions[pos - 1]) return {\r\n                            pos: pos,\r\n                            remove: buffer.length - 1\r\n                        };\r\n                    } else {\r\n                        pos -= opts.prefix.length;\r\n                        var radixPosition = $.inArray(opts.radixPoint, buffer), matchRslt = buffer.slice(0, radixPosition !== -1 ? radixPosition : void 0).join(\"\").match(opts.regex.integerNPart(opts));\r\n                        if (matchRslt && (radixPosition === -1 || pos <= radixPosition)) {\r\n                            var decimalPart = radixPosition === -1 ? 0 : parseInt(buffer.slice(radixPosition + 1).join(\"\"));\r\n                            if (0 === matchRslt[0].indexOf(\"\" !== opts.placeholder ? opts.placeholder.charAt(0) : \"0\") && (matchRslt.index + 1 === pos || isSelection !== !0 && 0 === decimalPart)) return maskset.buffer.splice(matchRslt.index + opts.prefix.length, 1), \r\n                            {\r\n                                pos: matchRslt.index + opts.prefix.length,\r\n                                remove: matchRslt.index + opts.prefix.length\r\n                            };\r\n                            if (\"0\" === chrs && pos <= matchRslt.index && matchRslt[0] !== opts.groupSeparator) return !1;\r\n                        }\r\n                    }\r\n                }\r\n                return !0;\r\n            },\r\n            definitions: {\r\n                \"~\": {\r\n                    validator: function(chrs, maskset, pos, strict, opts, isSelection) {\r\n                        var isValid = opts.signHandler(chrs, maskset, pos, strict, opts);\r\n                        if (!isValid && (isValid = opts.radixHandler(chrs, maskset, pos, strict, opts), \r\n                        !isValid && (isValid = strict ? new RegExp(\"[0-9\" + Inputmask.escapeRegex(opts.groupSeparator) + \"]\").test(chrs) : new RegExp(\"[0-9]\").test(chrs), \r\n                        isValid === !0 && (isValid = opts.leadingZeroHandler(chrs, maskset, pos, strict, opts, isSelection), \r\n                        isValid === !0)))) {\r\n                            var radixPosition = $.inArray(opts.radixPoint, maskset.buffer);\r\n                            isValid = radixPosition !== -1 && (opts.digitsOptional === !1 || maskset.validPositions[pos]) && opts.numericInput !== !0 && pos > radixPosition && !strict ? {\r\n                                pos: pos,\r\n                                remove: pos\r\n                            } : {\r\n                                pos: pos\r\n                            };\r\n                        }\r\n                        return isValid;\r\n                    },\r\n                    cardinality: 1\r\n                },\r\n                \"+\": {\r\n                    validator: function(chrs, maskset, pos, strict, opts) {\r\n                        var isValid = opts.signHandler(chrs, maskset, pos, strict, opts);\r\n                        return !isValid && (strict && opts.allowMinus && chrs === opts.negationSymbol.front || opts.allowMinus && \"-\" === chrs || opts.allowPlus && \"+\" === chrs) && (isValid = !(!strict && \"-\" === chrs) || (\"\" !== opts.negationSymbol.back ? {\r\n                            pos: pos,\r\n                            c: \"-\" === chrs ? opts.negationSymbol.front : \"+\",\r\n                            caret: pos + 1,\r\n                            insert: {\r\n                                pos: maskset.buffer.length,\r\n                                c: opts.negationSymbol.back\r\n                            }\r\n                        } : {\r\n                            pos: pos,\r\n                            c: \"-\" === chrs ? opts.negationSymbol.front : \"+\",\r\n                            caret: pos + 1\r\n                        })), isValid;\r\n                    },\r\n                    cardinality: 1,\r\n                    placeholder: \"\"\r\n                },\r\n                \"-\": {\r\n                    validator: function(chrs, maskset, pos, strict, opts) {\r\n                        var isValid = opts.signHandler(chrs, maskset, pos, strict, opts);\r\n                        return !isValid && strict && opts.allowMinus && chrs === opts.negationSymbol.back && (isValid = !0), \r\n                        isValid;\r\n                    },\r\n                    cardinality: 1,\r\n                    placeholder: \"\"\r\n                },\r\n                \":\": {\r\n                    validator: function(chrs, maskset, pos, strict, opts) {\r\n                        var isValid = opts.signHandler(chrs, maskset, pos, strict, opts);\r\n                        if (!isValid) {\r\n                            var radix = \"[\" + Inputmask.escapeRegex(opts.radixPoint) + \"]\";\r\n                            isValid = new RegExp(radix).test(chrs), isValid && maskset.validPositions[pos] && maskset.validPositions[pos].match.placeholder === opts.radixPoint && (isValid = {\r\n                                caret: pos + 1\r\n                            });\r\n                        }\r\n                        return isValid;\r\n                    },\r\n                    cardinality: 1,\r\n                    placeholder: function(opts) {\r\n                        return opts.radixPoint;\r\n                    }\r\n                }\r\n            },\r\n            onUnMask: function(maskedValue, unmaskedValue, opts) {\r\n                if (\"\" === unmaskedValue && opts.nullable === !0) return unmaskedValue;\r\n                var processValue = maskedValue.replace(opts.prefix, \"\");\r\n                return processValue = processValue.replace(opts.suffix, \"\"), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \r\n                opts.unmaskAsNumber ? (\"\" !== opts.radixPoint && processValue.indexOf(opts.radixPoint) !== -1 && (processValue = processValue.replace(Inputmask.escapeRegex.call(this, opts.radixPoint), \".\")), \r\n                Number(processValue)) : processValue;\r\n            },\r\n            isComplete: function(buffer, opts) {\r\n                var maskedValue = buffer.join(\"\"), bufClone = buffer.slice();\r\n                if (opts.postFormat(bufClone, 0, opts), bufClone.join(\"\") !== maskedValue) return !1;\r\n                var processValue = maskedValue.replace(opts.prefix, \"\");\r\n                return processValue = processValue.replace(opts.suffix, \"\"), processValue = processValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\"), \r\n                \",\" === opts.radixPoint && (processValue = processValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\")), \r\n                isFinite(processValue);\r\n            },\r\n            onBeforeMask: function(initialValue, opts) {\r\n                if (opts.numericInput === !0 && (initialValue = initialValue.split(\"\").reverse().join(\"\")), \r\n                \"\" !== opts.radixPoint && isFinite(initialValue)) initialValue = initialValue.toString().replace(\".\", opts.radixPoint); else {\r\n                    var kommaMatches = initialValue.match(/,/g), dotMatches = initialValue.match(/\\./g);\r\n                    dotMatches && kommaMatches ? dotMatches.length > kommaMatches.length ? (initialValue = initialValue.replace(/\\./g, \"\"), \r\n                    initialValue = initialValue.replace(\",\", opts.radixPoint)) : kommaMatches.length > dotMatches.length ? (initialValue = initialValue.replace(/,/g, \"\"), \r\n                    initialValue = initialValue.replace(\".\", opts.radixPoint)) : initialValue = initialValue.indexOf(\".\") < initialValue.indexOf(\",\") ? initialValue.replace(/\\./g, \"\") : initialValue = initialValue.replace(/,/g, \"\") : initialValue = initialValue.replace(new RegExp(Inputmask.escapeRegex(opts.groupSeparator), \"g\"), \"\");\r\n                }\r\n                if (0 === opts.digits && (initialValue.indexOf(\".\") !== -1 ? initialValue = initialValue.substring(0, initialValue.indexOf(\".\")) : initialValue.indexOf(\",\") !== -1 && (initialValue = initialValue.substring(0, initialValue.indexOf(\",\")))), \r\n                \"\" !== opts.radixPoint && isFinite(opts.digits) && initialValue.indexOf(opts.radixPoint) !== -1) {\r\n                    var valueParts = initialValue.split(opts.radixPoint), decPart = valueParts[1].match(new RegExp(\"\\\\d*\"))[0];\r\n                    if (parseInt(opts.digits) < decPart.toString().length) {\r\n                        var digitsFactor = Math.pow(10, parseInt(opts.digits));\r\n                        initialValue = initialValue.replace(Inputmask.escapeRegex(opts.radixPoint), \".\"), \r\n                        initialValue = Math.round(parseFloat(initialValue) * digitsFactor) / digitsFactor, \r\n                        initialValue = initialValue.toString().replace(\".\", opts.radixPoint);\r\n                    }\r\n                }\r\n                return opts.numericInput === !0 && (initialValue = initialValue.split(\"\").reverse().join(\"\")), \r\n                initialValue.toString();\r\n            },\r\n            canClearPosition: function(maskset, position, lvp, strict, opts) {\r\n                var positionInput = maskset.validPositions[position].input, canClear = positionInput !== opts.radixPoint || null !== maskset.validPositions[position].match.fn && opts.decimalProtect === !1 || isFinite(positionInput) || position === lvp || positionInput === opts.groupSeparator || positionInput === opts.negationSymbol.front || positionInput === opts.negationSymbol.back;\r\n                return canClear;\r\n            },\r\n            onKeyDown: function(e, buffer, caretPos, opts) {\r\n                var $input = $(this);\r\n                if (e.ctrlKey) switch (e.keyCode) {\r\n                  case Inputmask.keyCode.UP:\r\n                    $input.val(parseFloat(this.inputmask.unmaskedvalue()) + parseInt(opts.step)), $input.trigger(\"setvalue\");\r\n                    break;\r\n\r\n                  case Inputmask.keyCode.DOWN:\r\n                    $input.val(parseFloat(this.inputmask.unmaskedvalue()) - parseInt(opts.step)), $input.trigger(\"setvalue\");\r\n                }\r\n            }\r\n        },\r\n        currency: {\r\n            prefix: \"$ \",\r\n            groupSeparator: \",\",\r\n            alias: \"numeric\",\r\n            placeholder: \"0\",\r\n            autoGroup: !0,\r\n            digits: 2,\r\n            digitsOptional: !1,\r\n            clearMaskOnLostFocus: !1\r\n        },\r\n        decimal: {\r\n            alias: \"numeric\"\r\n        },\r\n        integer: {\r\n            alias: \"numeric\",\r\n            digits: 0,\r\n            radixPoint: \"\"\r\n        },\r\n        percentage: {\r\n            alias: \"numeric\",\r\n            digits: 2,\r\n            radixPoint: \".\",\r\n            placeholder: \"0\",\r\n            autoGroup: !1,\r\n            min: 0,\r\n            max: 100,\r\n            suffix: \" %\",\r\n            allowPlus: !1,\r\n            allowMinus: !1\r\n        }\r\n    }), Inputmask;\r\n}(jQuery, Inputmask), function($, Inputmask) {\r\n    function maskSort(a, b) {\r\n        var maska = (a.mask || a).replace(/#/g, \"9\").replace(/\\)/, \"9\").replace(/[+()#-]/g, \"\"), maskb = (b.mask || b).replace(/#/g, \"9\").replace(/\\)/, \"9\").replace(/[+()#-]/g, \"\"), maskas = (a.mask || a).split(\"#\")[0], maskbs = (b.mask || b).split(\"#\")[0];\r\n        return 0 === maskbs.indexOf(maskas) ? -1 : 0 === maskas.indexOf(maskbs) ? 1 : maska.localeCompare(maskb);\r\n    }\r\n    var analyseMaskBase = Inputmask.analyseMask;\r\n    return Inputmask.analyseMask = function(mask, opts) {\r\n        function reduceVariations(masks, previousVariation, previousmaskGroup) {\r\n            previousVariation = previousVariation || \"\", previousmaskGroup = previousmaskGroup || maskGroups, \r\n            \"\" !== previousVariation && (previousmaskGroup[previousVariation] = {});\r\n            for (var variation = \"\", maskGroup = previousmaskGroup[previousVariation] || previousmaskGroup, i = masks.length - 1; i >= 0; i--) mask = masks[i].mask || masks[i], \r\n            variation = mask.substr(0, 1), maskGroup[variation] = maskGroup[variation] || [], \r\n            maskGroup[variation].unshift(mask.substr(1)), masks.splice(i, 1);\r\n            for (var ndx in maskGroup) maskGroup[ndx].length > 1e3 && reduceVariations(maskGroup[ndx].slice(), ndx, maskGroup);\r\n        }\r\n        function rebuild(maskGroup) {\r\n            var mask = \"\", submasks = [];\r\n            for (var ndx in maskGroup) $.isArray(maskGroup[ndx]) ? 1 === maskGroup[ndx].length ? submasks.push(ndx + maskGroup[ndx]) : submasks.push(ndx + opts.groupmarker.start + maskGroup[ndx].join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end) : submasks.push(ndx + rebuild(maskGroup[ndx]));\r\n            return mask += 1 === submasks.length ? submasks[0] : opts.groupmarker.start + submasks.join(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start) + opts.groupmarker.end;\r\n        }\r\n        var maskGroups = {};\r\n        opts.phoneCodes && opts.phoneCodes.length > 500 && (mask = mask.substr(1, mask.length - 2), \r\n        reduceVariations(mask.split(opts.groupmarker.end + opts.alternatormarker + opts.groupmarker.start)), \r\n        mask = rebuild(maskGroups)), console.log(mask);\r\n        var mt = analyseMaskBase.call(this, mask, opts);\r\n        return mt;\r\n    }, Inputmask.extendAliases({\r\n        abstractphone: {\r\n            groupmarker: {\r\n                start: \"<\",\r\n                end: \">\"\r\n            },\r\n            countrycode: \"\",\r\n            phoneCodes: [],\r\n            mask: function(opts) {\r\n                return opts.definitions = {\r\n                    \"#\": opts.definitions[9]\r\n                }, opts.phoneCodes.sort(maskSort);\r\n            },\r\n            keepStatic: !0,\r\n            onBeforeMask: function(value, opts) {\r\n                var processedValue = value.replace(/^0{1,2}/, \"\").replace(/[\\s]/g, \"\");\r\n                return (processedValue.indexOf(opts.countrycode) > 1 || processedValue.indexOf(opts.countrycode) === -1) && (processedValue = \"+\" + opts.countrycode + processedValue), \r\n                processedValue;\r\n            },\r\n            onUnMask: function(maskedValue, unmaskedValue, opts) {\r\n                return unmaskedValue;\r\n            },\r\n            inputmode: \"tel\"\r\n        }\r\n    }), Inputmask;\r\n}(jQuery, Inputmask), function($, Inputmask) {\r\n    return Inputmask.extendAliases({\r\n        Regex: {\r\n            mask: \"r\",\r\n            greedy: !1,\r\n            repeat: \"*\",\r\n            regex: null,\r\n            regexTokens: null,\r\n            tokenizer: /\\[\\^?]?(?:[^\\\\\\]]+|\\\\[\\S\\s]?)*]?|\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\\S\\s]?)|\\((?:\\?[:=!]?)?|(?:[?*+]|\\{[0-9]+(?:,[0-9]*)?\\})\\??|[^.?*+^${[()|\\\\]+|./g,\r\n            quantifierFilter: /[0-9]+[^,]/,\r\n            isComplete: function(buffer, opts) {\r\n                return new RegExp(opts.regex).test(buffer.join(\"\"));\r\n            },\r\n            definitions: {\r\n                r: {\r\n                    validator: function(chrs, maskset, pos, strict, opts) {\r\n                        function RegexToken(isGroup, isQuantifier) {\r\n                            this.matches = [], this.isGroup = isGroup || !1, this.isQuantifier = isQuantifier || !1, \r\n                            this.quantifier = {\r\n                                min: 1,\r\n                                max: 1\r\n                            }, this.repeaterPart = void 0;\r\n                        }\r\n                        function analyseRegex() {\r\n                            var match, m, currentToken = new RegexToken(), opengroups = [];\r\n                            for (opts.regexTokens = []; match = opts.tokenizer.exec(opts.regex); ) switch (m = match[0], \r\n                            m.charAt(0)) {\r\n                              case \"(\":\r\n                                opengroups.push(new RegexToken((!0)));\r\n                                break;\r\n\r\n                              case \")\":\r\n                                groupToken = opengroups.pop(), opengroups.length > 0 ? opengroups[opengroups.length - 1].matches.push(groupToken) : currentToken.matches.push(groupToken);\r\n                                break;\r\n\r\n                              case \"{\":\r\n                              case \"+\":\r\n                              case \"*\":\r\n                                var quantifierToken = new RegexToken((!1), (!0));\r\n                                m = m.replace(/[{}]/g, \"\");\r\n                                var mq = m.split(\",\"), mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]), mq1 = 1 === mq.length ? mq0 : isNaN(mq[1]) ? mq[1] : parseInt(mq[1]);\r\n                                if (quantifierToken.quantifier = {\r\n                                    min: mq0,\r\n                                    max: mq1\r\n                                }, opengroups.length > 0) {\r\n                                    var matches = opengroups[opengroups.length - 1].matches;\r\n                                    match = matches.pop(), match.isGroup || (groupToken = new RegexToken((!0)), groupToken.matches.push(match), \r\n                                    match = groupToken), matches.push(match), matches.push(quantifierToken);\r\n                                } else match = currentToken.matches.pop(), match.isGroup || (groupToken = new RegexToken((!0)), \r\n                                groupToken.matches.push(match), match = groupToken), currentToken.matches.push(match), \r\n                                currentToken.matches.push(quantifierToken);\r\n                                break;\r\n\r\n                              default:\r\n                                opengroups.length > 0 ? opengroups[opengroups.length - 1].matches.push(m) : currentToken.matches.push(m);\r\n                            }\r\n                            currentToken.matches.length > 0 && opts.regexTokens.push(currentToken);\r\n                        }\r\n                        function validateRegexToken(token, fromGroup) {\r\n                            var isvalid = !1;\r\n                            fromGroup && (regexPart += \"(\", openGroupCount++);\r\n                            for (var mndx = 0; mndx < token.matches.length; mndx++) {\r\n                                var matchToken = token.matches[mndx];\r\n                                if (matchToken.isGroup === !0) isvalid = validateRegexToken(matchToken, !0); else if (matchToken.isQuantifier === !0) {\r\n                                    var crrntndx = $.inArray(matchToken, token.matches), matchGroup = token.matches[crrntndx - 1], regexPartBak = regexPart;\r\n                                    if (isNaN(matchToken.quantifier.max)) {\r\n                                        for (;matchToken.repeaterPart && matchToken.repeaterPart !== regexPart && matchToken.repeaterPart.length > regexPart.length && !(isvalid = validateRegexToken(matchGroup, !0)); ) ;\r\n                                        isvalid = isvalid || validateRegexToken(matchGroup, !0), isvalid && (matchToken.repeaterPart = regexPart), \r\n                                        regexPart = regexPartBak + matchToken.quantifier.max;\r\n                                    } else {\r\n                                        for (var i = 0, qm = matchToken.quantifier.max - 1; i < qm && !(isvalid = validateRegexToken(matchGroup, !0)); i++) ;\r\n                                        regexPart = regexPartBak + \"{\" + matchToken.quantifier.min + \",\" + matchToken.quantifier.max + \"}\";\r\n                                    }\r\n                                } else if (void 0 !== matchToken.matches) for (var k = 0; k < matchToken.length && !(isvalid = validateRegexToken(matchToken[k], fromGroup)); k++) ; else {\r\n                                    var testExp;\r\n                                    if (\"[\" == matchToken.charAt(0)) {\r\n                                        testExp = regexPart, testExp += matchToken;\r\n                                        for (var j = 0; j < openGroupCount; j++) testExp += \")\";\r\n                                        var exp = new RegExp(\"^(\" + testExp + \")$\");\r\n                                        isvalid = exp.test(bufferStr);\r\n                                    } else for (var l = 0, tl = matchToken.length; l < tl; l++) if (\"\\\\\" !== matchToken.charAt(l)) {\r\n                                        testExp = regexPart, testExp += matchToken.substr(0, l + 1), testExp = testExp.replace(/\\|$/, \"\");\r\n                                        for (var j = 0; j < openGroupCount; j++) testExp += \")\";\r\n                                        var exp = new RegExp(\"^(\" + testExp + \")$\");\r\n                                        if (isvalid = exp.test(bufferStr)) break;\r\n                                    }\r\n                                    regexPart += matchToken;\r\n                                }\r\n                                if (isvalid) break;\r\n                            }\r\n                            return fromGroup && (regexPart += \")\", openGroupCount--), isvalid;\r\n                        }\r\n                        var bufferStr, groupToken, cbuffer = maskset.buffer.slice(), regexPart = \"\", isValid = !1, openGroupCount = 0;\r\n                        null === opts.regexTokens && analyseRegex(), cbuffer.splice(pos, 0, chrs), bufferStr = cbuffer.join(\"\");\r\n                        for (var i = 0; i < opts.regexTokens.length; i++) {\r\n                            var regexToken = opts.regexTokens[i];\r\n                            if (isValid = validateRegexToken(regexToken, regexToken.isGroup)) break;\r\n                        }\r\n                        return isValid;\r\n                    },\r\n                    cardinality: 1\r\n                }\r\n            }\r\n        }\r\n    }), Inputmask;\r\n}(jQuery, Inputmask);\r\n\r\n$(document).ready(function(){\r\n  // $('.modal-form__input--tel').inputmask(\"99-9999999\");\r\n $('.modal-form__input--tel').inputmask({\"mask\": \"+7 (999) 999-99-99\"});\r\n  // $('.modal-form__input--tel').inputmask(\"9-a{1,3}9{1,3}\");\r\n});","// nav-list\r\nmainMenu('.nav-list','.nav-toggle'); \r\nfunction mainMenu(menu,btn){ \r\n\tvar menu = $(menu), \r\n\tbtn = $(btn); \r\n\tbtn.on('click',function(){ \r\n\t\tbtn.blur(); \r\n\t\tif(btn.hasClass('disable')){ \r\n\t\t\tbtn.removeClass('disable') \r\n\t\t\tbtn.attr(\"data-disable\",\"false\") \r\n\t\t\tmenu.removeClass('disable'); \r\n\t\t\tmenu.slideDown(300); \r\n\t\t}else{ \r\n\t\t\tbtn.addClass('disable') \r\n\t\t\tbtn.attr(\"data-disable\",\"true\") \r\n\t\t\tmenu.addClass('disable'); \r\n\t\t\tmenu.slideUp(300); \r\n\t\t} \r\n\t}) \r\n\t$(btn).attr(\"data-disable\",\"true\"); \r\n\ttoggleMenu(btn,menu); \r\n\t$(window).resize(function(){ \r\n\t\ttoggleMenu(btn,menu); \r\n\t}) \r\n\tfunction toggleMenu(btn,menu){ \r\n\t\tif($(btn).is(\":visible\") && $(btn).attr(\"data-disable\")==\"true\"){ \r\n\t\t\t$(btn).addClass('disable'); \r\n\t\t\t$(menu).addClass('disable'); \r\n\t\t\t$(menu).hide(); \r\n\t\t}else if(!$(btn).is(\":visible\")){ \r\n\t\t\t$(btn).removeClass('disable'); \r\n\t\t\t$(menu).removeClass('disable'); \r\n\t\t\t$(menu).show(); \r\n\t\t} \r\n\t} \r\n}\r\n\r\n// nav-toggle\r\n$('.nav-toggle').on('click', function(){\r\n\t$(this).toggleClass('nav-toggle--open')\r\n})","});"],"sourceRoot":"/source/"}